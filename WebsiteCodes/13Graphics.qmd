---
title: "Generating Visual Outputs"
subtitle: ""
description: "Materials adapted from Adrien Osakwe, Larisa M. Soto and Xiaoqi Xie."
---

------------------------------------------------------------------------

## 1. Graphics with Base R

Base R is great for a "quick look" at your data. It is fast because it doesn't require any extra libraries, but it can be difficult to customize once your plots get complex.

### Simple Histogram

```{r}
#| message: false
if (!require("gapminder", quietly = TRUE))
    install.packages("gapminder")
library(gapminder)

hist(gapminder$lifeExp, 
     xlab = "Life expectancy", 
     main = "Histogram of Life Expectancy", 
     col  = "lightblue")
```

### Multi-panel Plots with `par()`

If you want to see multiple variables at once (e.g., for Switzerland), you can use `par(mfrow = c(rows, cols))` to divide your plotting window.

```{r}
df_swiss <- gapminder[gapminder$country == "Switzerland", ]
par(mfrow = c(1, 3)) # 1 row, 3 columns

plot(y = df_swiss$lifeExp, x = df_swiss$year, xlab = "Years", ylab = "Life expectancy", type = "b")
plot(y = df_swiss$pop, x = df_swiss$year, xlab = "Years", ylab = "Population size", type = "b")
plot(y = df_swiss$gdpPercap, x = df_swiss$year, xlab = "Years", ylab = "GDP per capita", type = "b")
```

## 2. Graphics with `ggplot2`

`ggplot2` is based on the **Grammar of Graphics**. Instead of thinking about "plots," we think about **layers**:

1.  **Data:** The dataframe you are using.

2.  **Aesthetics (`aes`):** Mapping data columns to visual properties (x, y, color, size).

3.  **Geometries (`geom`):** The visual marks (points, lines, bars).

### Comparing Multiple Countries

```{r}
#| message: false
library(ggplot2)
library(dplyr)

df_subset <- gapminder %>%
      dplyr::filter(country %in% c("Switzerland", "Australia", "Zimbabwe", "India"))
      
ggplot(df_subset, aes(x = year, y = lifeExp, color = country)) +
  geom_point() +
  geom_line() +
  theme_minimal()
```

### The "All-in-One" Pipeline

One of the best features of the Tidyverse is that you can pipe your data manipulation results directly into `ggplot()`. This avoids creating unnecessary intermediate objects in your environment.

```{r}
#| message: false
gapminder %>%
  dplyr::group_by(continent, year) %>%
  dplyr::summarize(mean_gdpPercap = mean(gdpPercap)) %>%
  ggplot(aes(x = year, y = mean_gdpPercap, color = continent)) +
    geom_point() +
    geom_line() +
    labs(title = "Mean GDP per Capita by Continent", y = "Mean GDP")
```

## 3. Advanced `ggplot2` Tricks

### Data Format (Wide vs. Long)

`ggplot2` almost always expects data in **Long Format** (one column for the category, one column for the value). If your data is "Wide" (e.g., each year is its own column), you must tidy it first.

### Controlling Colors & Factors

If you want your legend to appear in a specific order (e.g., descending wealth), you must modify the **Levels** of your factor.

```{r}
#| message: false
gapminder %>%
  dplyr::group_by(continent, year) %>%
  dplyr::mutate(continent = factor(as.character(continent), 
                                   levels = c("Oceania", "Europe", "Americas", "Asia", "Africa"))) %>%
  dplyr::summarize(mean_gdpPercap = mean(gdpPercap)) %>%
  ggplot(aes(x = year, y = mean_gdpPercap, color = continent)) +
    geom_line(linewidth = 1) +
    scale_color_viridis_d() # Uses a colorblind-friendly palette
```
