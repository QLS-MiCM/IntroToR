[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Intro to Programming in R",
    "section": "",
    "text": "This workshop is beginner-level introduction to programming in R. The course is designed to be taught in one session of 4 hours and is focused on the application of R to the analysis of tabular data from medical datasets.",
    "crumbs": [
      "WelcomeğŸ‰"
    ]
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Intro to Programming in R",
    "section": "",
    "text": "This workshop is beginner-level introduction to programming in R. The course is designed to be taught in one session of 4 hours and is focused on the application of R to the analysis of tabular data from medical datasets.",
    "crumbs": [
      "WelcomeğŸ‰"
    ]
  },
  {
    "objectID": "index.html#the-workshop-materials",
    "href": "index.html#the-workshop-materials",
    "title": "Intro to Programming in R",
    "section": "0. The Workshop Materials",
    "text": "0. The Workshop Materials\nThroughout this course, we will primarily use our dedicated workshop website: ğŸ‘‰ Introduction to R Workshop: https://martinahyang.github.io/IntroToR/\nWe will use this site to cover the foundational concepts of R, while performing hands-on exercises together in the RStudio. All necessary code and resources are provided on the site for your convenience.",
    "crumbs": [
      "WelcomeğŸ‰"
    ]
  },
  {
    "objectID": "index.html#prior-knowledge",
    "href": "index.html#prior-knowledge",
    "title": "Intro to Programming in R",
    "section": "1. Prior knowledge",
    "text": "1. Prior knowledge\n\nNo previous programming experience is required.\nPlease review the following topics if youâ€™re not comfortable with them:\n\nbasic linear algebra (operations with vectors and metrics)\nmathematical operations (exponential, logarithms)\nbasic statistics (mean, variance, median, standard deviation)\nlogical statements (AND, OR, NOT)",
    "crumbs": [
      "WelcomeğŸ‰"
    ]
  },
  {
    "objectID": "index.html#software-requirements",
    "href": "index.html#software-requirements",
    "title": "Intro to Programming in R",
    "section": "2. Software requirements",
    "text": "2. Software requirements\n\nR &gt; 4.0\nRStudio\n\nYou could refer to the step-by-step instructions Getting Started: Installing R and RStudio.\nOnce you have setup R and RStudio copy the code below to install the packages required for the workshop.\n\n# Installing necessary packages\n\ninstall.packages(c(\"data.table\", \"datasets\", \"devtools\", \"dplyr\", \"ggplot2\", \"plyr\", \"medicaldata\", \"gapminder\", \"RColorBrewer\", \"rmarkdown\", \"stringr\", \"tidyr\", \"tidyverse\", \"viridis\"))\n\n\nDonâ€™t panic if you get stuck!\nWhile it helps to be ready before class, weâ€™ve set aside 15 minutes of the workshop to help anyone running into errors.",
    "crumbs": [
      "WelcomeğŸ‰"
    ]
  },
  {
    "objectID": "index.html#workshop-outline",
    "href": "index.html#workshop-outline",
    "title": "Intro to Programming in R",
    "section": "3. Workshop Outline",
    "text": "3. Workshop Outline\n\n3.1 R basics\nIn the first module of the workshop, the goals are to (1) familiarize with the language and the logic behind it; (2) Get started with R studio and create your first project; (3) Configure the working directory with a common standard structure; (4) Create your first .R file to write down the live code; (5) Compute arithmetic operations; (6) Use logical operators; (7) Get fluent in Râ€™s console; (8) Learn how to ask for help within R; and (9) get comfortable with installing packages.\nModule content:\n\nSyntax\nArithmetic Operations\nCreating variables\nLogical operators\nSeeking help\nInstalling packages\nHands on: basics\n\n\n\n3.2 Data types: attributes and built-in functions\nIn this section participants will (1) understand the differences between classes, objects and data types in R; (2) create objects of different types, learn about their attributes and apply some built-in functions in R; (3) Subset and index objects; and (4) get comfortable with vectorized operations.\nModule content:\n\nVectors\nLists\nFactors\nData frames\nArrays\nCoercion\nHands-on: data types\n\n\n\n3.3 Basic data manipulation\nIn this module participants will (1) learn how to read/write data to/from files with different formats (.tsv, .csv); (2) become familiar with basic data-frame operations; (3) index and subset data frames using base R; (4) manipulate individual data frame columns; and (5) learn how to join columns and rows of different data frames using base R.\nModule content:\n\nReading/writing data\nExploring data frames\nHands-on: basic data manipulation\n\n\n\n3.4 Advanced data manipulation\nThe fourth module participants will (1) familiarize with the dplyr syntax; (2) create pipes with the operator %&gt;%; (3) perform operations on data frames using dplyr and tidyr functions; and (4) implement functions from external packages by reading their documentation in R\nModule content:\n\nHandling data frames with dplyr\nOther useful packages\nHands-on: advanced data manipulation\n\n\n\n3.5 Generating visual outputs\nThis section will show participants how to (1) Create basic plots using base R functions; (2) Understand how to connect data frames with ggplot2; (3) create basic graphs with ggplot2; (4) use factors to customize graphics in ggplot2; (5) use RMarkdown to generate customized reports.\nModule content:\n\nFigures with base R\nGraphics with ggplot2\n\n\n\n3.6 Real life application: COVID testing dataset\nThis hands-on activity will familiarize participants with a real-life use of R in the pharma industry environment and encourage them to apply the knowledge from previous modules to create an analysis pipeline.\n\n\n3.7 Software development concepts\nTo conclude the workshop, participants will (1) acquire good coding practices; (2) be familiar with code documentation standards; (3) know what to avoid when programming in R; (4) learn how to debug and troubleshoot their own code.\nModule content:\n\nGood coding practices\nStyle guide\nDebugging and troubleshooting",
    "crumbs": [
      "WelcomeğŸ‰"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Intro to Programming in R",
    "section": "4. References",
    "text": "4. References\nThe materials for this workshop were based on the following sources:\n\nBase R Cheat Sheet\nGoogleâ€™s R Style Guide\nMastering Software Development in R\nOnline Book: R for Data Science (2e)\nOnline Book: R Graphics Cookbook, 2nd edition\nOnline Book: R in Action, Second Edition\nOnline Book: Hands-On Programming with R\n\nWorkshop created as part of the McGill Initiative in Computational Medicine",
    "crumbs": [
      "WelcomeğŸ‰"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions4.html",
    "href": "WebsiteCodes/Solutions4.html",
    "title": "Solutions: Medical Data",
    "section": "",
    "text": "if (!require(\"ggplot2\", quietly = TRUE))\n    install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\nif (!require(\"medicaldata\", quietly = TRUE))\n    install.packages(\"medicaldata\")\nlibrary(medicaldata)\n\nif (!require(\"dplyr\", quietly = TRUE))\n    install.packages(\"dplyr\")\nlibrary(dplyr)\n\nif (!require(\"tidyr\", quietly = TRUE))\n    install.packages(\"tidyr\")\nlibrary(tidyr)\nUse the covid_testing data set from package medicaldata and everything youâ€™ve learned so far to answer the following questions:",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼”"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions4.html#clinics-included",
    "href": "WebsiteCodes/Solutions4.html#clinics-included",
    "title": "Solutions: Medical Data",
    "section": "Clinics included",
    "text": "Clinics included\nHow many clinics participated in the study, and how many valid tests were performed on each one? Did the testing trend vary over time?\n\ncovid&lt;-covid_testing\n\n\nNumber of clinics\n\nclinics&lt;- covid %&gt;%\n          dplyr::select(subject_id,clinic_name,result,pan_day) %&gt;%\n          dplyr::distinct()\nlength(unique(clinics$clinic_name))\n\n[1] 88\n\n\n\n\nNumber of valid tests\n\nclinics %&gt;%\n  dplyr::filter(result!=\"invalid\") %&gt;%\n  dplyr::group_by(clinic_name) %&gt;%\n  dplyr::summarize(n_test = length(clinic_name)) %&gt;%\n  dplyr::arrange(desc(n_test))\n\n# A tibble: 88 Ã— 2\n   clinic_name        n_test\n   &lt;chr&gt;               &lt;int&gt;\n 1 clinical lab         7397\n 2 emergency dept       3353\n 3 oncology day hosp     509\n 4 nicu                  285\n 5 laboratory            262\n 6 picu                  258\n 7 care ntwk             231\n 8 line clinical lab-    218\n 9 inpatient ward a      207\n10 radiation oncology    161\n# â„¹ 78 more rows\n\n\n\n\n\n\n\n\nNote\n\n\n\nStep-by-Step Breakdown\n\nfilter(result != \"invalid\")\n\nYou are â€œcleaning the pipe.â€ Before doing any math, you remove the â€œnoise.â€\n\nThe Question: â€œIs this a real test result?â€\nThe Action: Only rows where the result is NOT â€œinvalidâ€ are allowed to move to the next step.\n\n\ngroup_by(clinic_name)\n\nYou are â€œsorting the mail.â€ R doesnâ€™t calculate anything yet; it just creates invisible folders for each clinic.\n\nThe Action: R puts all â€œClinic Aâ€ rows in one bucket and â€œClinic Bâ€ rows in another.\n\n\nsummarize(n_test = length(clinic_name))\n\nYou are â€œcollapsing the buckets.â€ This is where the many rows of your original data become one single summary row per group.\n\nThe Action: Inside each clinicâ€™s bucket, R counts how many items are there.\nNote: You can also use the shorthand n() instead of length(clinic_name)â€”it does the exact same thing!\n\n\narrange(desc(n_test))\n\nYou are â€œranking the results.â€\n\nThe Action: By default, R sorts low-to-high. desc() (descending) flips it so the clinic with the most tests appears at the very top.\n\n\n\n\n\nTesting trend over time\n\ncovid %&gt;%\n  filter(pan_day&lt;=100) %&gt;%\n  group_by(pan_day) %&gt;%\n  summarize(n=length(result)) %&gt;%\n  ggplot(.,aes(x=pan_day,y=n))+\n    geom_point()+\n    geom_line()+\n    ylab(\"Number of tests per day\")+\n    xlab(\"Pandemic day\")",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼”"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions4.html#number-of-positive-tests",
    "href": "WebsiteCodes/Solutions4.html#number-of-positive-tests",
    "title": "Solutions: Medical Data",
    "section": "Number of positive tests",
    "text": "Number of positive tests\nHow many patients tested positive vs negative in the first 100 days of the pandemic? Do you notice any difference with the age of the patients? Hint: You can make two age groups and calculate the percentage each age group in positive vs negative tests.\n\nNumber of positive tests in the first 100 days\n\ncovid %&gt;%\n  filter(result!=\"invalid\" & pan_day&lt;=100) %&gt;%\n  group_by(result) %&gt;%\n  summarize(n=length(subject_id))\n\n# A tibble: 2 Ã— 2\n  result       n\n  &lt;chr&gt;    &lt;int&gt;\n1 negative 13225\n2 positive   780\n\n\n\n\nTests by age group\n\ntsts_age&lt;-covid %&gt;%\n            filter(result!=\"invalid\" & pan_day&lt;=100) %&gt;%\n            mutate(age_group=ifelse(age&lt;=21,\"children\",\"adults\")) %&gt;%\n            group_by(age_group,result) %&gt;%\n            summarize(n=length(subject_id)) %&gt;%\n            mutate(percent_total=n/sum(n)*100)\ntsts_age\n\n# A tibble: 4 Ã— 4\n# Groups:   age_group [2]\n  age_group result       n percent_total\n  &lt;chr&gt;     &lt;chr&gt;    &lt;int&gt;         &lt;dbl&gt;\n1 adults    negative  2627         92.1 \n2 adults    positive   226          7.92\n3 children  negative 10598         95.0 \n4 children  positive   554          4.97\n\n\n\n\n\n\n\n\nNote\n\n\n\n1. The Cleaning Phase (filter)\n\nfilter(result != \"invalid\" & pan_day &lt;= 100)\n\nBefore any analysis, you are narrowing the focus to high-quality, early-pandemic data.\n\nresult != \"invalid\": Removes tests that didnâ€™t work (QC failure).\n&: A logical â€œAND.â€ Both conditions must be true.\npan_day &lt;= 100: Only includes data from the first 100 days of the pandemic.\n\n2. The Classification Phase (mutate)\n\nmutate(age_group = ifelse(age &lt;= 21, \"children\", \"adults\"))\n\nYou are creating a new column â€œon the flyâ€ to categorize your patients.\n\nifelse(test, yes, no): This is a logical switch. If a patient is 21 or younger, they are labeled â€œchildrenâ€; otherwise, they are â€œadults.â€\n\n3. The Organization Phase (group_by)\n\ngroup_by(age_group, result)\n\nThis is the most critical step. You are telling R to create sub-buckets for every combination of age and test outcome (e.g., â€œadults-positive,â€ â€œadults-negative,â€ â€œchildren-positive,â€ etc.).\n4. The Aggregation Phase (summarize)\n\nsummarize(n = length(subject_id))\n\nR collapses the buckets created in the previous step.\n\nIt counts how many subject_id entries are in each bucket and stores that number in a new column called n.\n\n5. The Calculation Phase (mutate)\n\nmutate(percent_total = n / sum(n) * 100)\n\nThis is a â€œSmart Calculation.â€ Because the data is still grouped by age_group, the sum(n) happens separately for each group.\n\nExample: For the â€œadultsâ€ rows, it divides their count by the total number of adults.\nThis gives you the percentage of results within that specific age group, rather than the percentage of the entire dataset.\n\n\nNotes on sum(n)\nIn this specific code, the percent_total will represent the percentage of results per age group (e.g., what % of children were positive vs.Â negative). If you wanted the percentage of the entire table, you would need to ungroup() the data before this last mutate.",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼”"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions4.html#processing-times",
    "href": "WebsiteCodes/Solutions4.html#processing-times",
    "title": "Solutions: Medical Data",
    "section": "Processing times",
    "text": "Processing times\nLook at the specimen processing time to receipt, did the sample processing times improve over the first 100 days of the pandemic? Plot the median processing times of each day over the course of the pandemic and then compare the summary statistics of the first 50 vs the last 50 days\n\ncovid %&gt;%\n  group_by(pan_day) %&gt;%\n  dplyr::summarise(median_col_rec_tat=median(col_rec_tat)) %&gt;%\n  ggplot(.,aes(x=pan_day,y=median_col_rec_tat)) +\n  geom_point()+\n  geom_line()\n\n\n\n\n\n\n\n\n\ncovid %&gt;%\n  mutate(pan_day_group=ifelse(pan_day&lt;50,\"first_50\",\"last_50\")) %&gt;%\n  group_by(pan_day_group) %&gt;%\n  dplyr::summarise(mean_col_rec_tat=mean(col_rec_tat),\n                   median_col_rec_tat=median(col_rec_tat),\n                   min_col_rec_tat=min(col_rec_tat),\n                   max_col_rec_tat=max(col_rec_tat))\n\n# A tibble: 2 Ã— 5\n  pan_day_group mean_col_rec_tat median_col_rec_tat min_col_rec_tat\n  &lt;chr&gt;                    &lt;dbl&gt;              &lt;dbl&gt;           &lt;dbl&gt;\n1 first_50                  3.26                1.9               0\n2 last_50                   9.41                1.9               0\n# â„¹ 1 more variable: max_col_rec_tat &lt;dbl&gt;",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼”"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions4.html#bonus---viral-load",
    "href": "WebsiteCodes/Solutions4.html#bonus---viral-load",
    "title": "Solutions: Medical Data",
    "section": "Bonus - Viral load",
    "text": "Bonus - Viral load\nHigher viral loads are detected in less PCR cycles.\nWhat can you observe about the viral load of positive vs negative samples.\nDo you notice anything differences in viral load across ages in the positive samples?\nHint: Also split the data into two age groups and try using geom_boxplot()\n\nggplot(covid,aes(y=ct_result,x=result,color=result))+\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\ncovid %&gt;%\n  mutate(age_group=ifelse(age&lt;=21,\"children\",\"adults\")) %&gt;%\n  ggplot(.,aes(y=ct_result,x=result,color=age_group))+\n    geom_boxplot()",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼”"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions2.html",
    "href": "WebsiteCodes/Solutions2.html",
    "title": "Solutions: Basic Data Manipulation",
    "section": "",
    "text": "library(gapminder)",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼’"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions2.html#writing-data",
    "href": "WebsiteCodes/Solutions2.html#writing-data",
    "title": "Solutions: Basic Data Manipulation",
    "section": "Writing data",
    "text": "Writing data\nWrite a data processing snippet to include only the data points collected after 1995 in Asian countries as a CSV file\n\nasia&lt;-gapminder[gapminder$year &gt; 1995 & gapminder$continent==\"Asia\", ]\nwrite.table(asia,\n            file = \"../data/gapminder_after1995_asia.csv\",\n            sep = \",\", \n            quote = FALSE, \n            row.names = FALSE)\n\nSeparate the gapminder data frame into 5 individual data frames, one for each continent. Store those 5 data frames as an RData file in the objects folder called continents.RData.\n\nasia&lt;-gapminder[gapminder$continent==\"Asia\", ]\nafrica&lt;-gapminder[gapminder$continent==\"Africa\", ]\noceania&lt;-gapminder[gapminder$continent==\"Oceania\", ]\neurope&lt;-gapminder[gapminder$continent==\"Europe\", ]\namericas&lt;-gapminder[gapminder$continent==\"Americas\", ]\n\nsave(asia,africa,oceania,europe,americas,file=\"../data/continents.RData\")\n\n\n\n\n\n\n\nNote\n\n\n\nUnderstanding File Paths: The Tree Analogy\nWhen you are working in an RStudio Project, yourÂ Working DirectoryÂ is your â€œHome Base.â€ Think of your folders as a tree:\n\n./Â (The Current Folder):Â This is where yourÂ .qmdÂ orÂ .RmdÂ file is currently saved.\n../Â (The Parent Folder):Â This tells R to moveÂ upÂ one level in the folder tree.\n../../Â (The Grandparent Folder):Â This moves up two levels.\n\nBreakdown ofÂ \"../data/continents.RData\"\nWhen you run that code, you are telling R to follow these exact steps:\n\n../: Leave the current folder (e.g., theÂ scriptsÂ orÂ vignettesÂ folder).\ndata/: Look for a folder namedÂ dataÂ at that higher level.\ncontinents.RData: Save the file inside that folder with this specific name.\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe â€œFolder Not Foundâ€ Error\nR is a great calculator, but it isnâ€™t a folder manager. If you tell R to save a file in a folder namedÂ data/Â but that folder doesnâ€™t exist yet, R will throw an error:Â No such file or directory.\nBefore saving, you must create the folder manually or use this code:\n\n# Create a 'data' folder in your current working directory\ndir.create(\"data\")",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼’"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions2.html#exploring-data-frames",
    "href": "WebsiteCodes/Solutions2.html#exploring-data-frames",
    "title": "Solutions: Basic Data Manipulation",
    "section": "Exploring data frames",
    "text": "Exploring data frames\nFinish exploring the gapminder data frame and:\n\nFind the number of rows and the number of columns\n\nPrint the data type of each column\n\nExplain the meaning of everything that str(gapminder) prints\n\n\ndim(gapminder)\n\ntypeof(gapminder$country)\ntypeof(gapminder$continent)\ntypeof(gapminder$year)\ntypeof(gapminder$lifeExp)\ntypeof(gapminder$pop)\ntypeof(gapminder$gdpPercap)\n\nstr(gapminder)\n\n\n\n\n\n\n\nNote\n\n\n\nColumn Data Types\nWhileÂ typeof()Â gives you the low-level R storage type, in data analysis, we often care more about theÂ classÂ (how R treats the data).\n\n\n\n\n\n\n\n\nColumn\ntypeof() result\nInterpretation\n\n\ncountry\ninteger\nStored as numbers (1, 2, 3) because it is aÂ Factor.\n\n\ncontinent\ninteger\nAlso aÂ FactorÂ (categorical data).\n\n\nyear\ninteger\nDiscrete whole numbers.\n\n\nlifeExp\ndouble\nFloating-point numbers (decimals).\n\n\npop\ninteger\nWhole numbers (count data).\n\n\ngdpPercap\ndouble\nFloating-point numbers (decimals).\n\n\n\n\nclass(gapminder$country)\nclass(gapminder$continent)\nclass(gapminder$year)\nclass(gapminder$lifeExp)\nclass(gapminder$pop)\nclass(gapminder$gdpPercap)\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nTheÂ str()Â Output\nTheÂ str()Â (Structure) function is arguably the most useful command in Base R. It provides a compact summary of any object.\nThe Header\ntibble [1,704 Ã— 6] (S3: tbl_df/tbl/data.frame)\n\ntibble / data.frame: This tells you the object â€œflavor.â€ A tibble is a modern, user-friendly version of a data frame used in the Tidyverse.\n[1,704 x 6]: Confirms the dimensions (Rows x Columns).\n\nThe Column Details\n\n$ country : Factor w/ 142 levels:\n\nFactor: This isÂ CategoricalÂ data.\n142 levels: There are 142 unique countries.\n1 1 1...: Internally, R stores â€œAfghanistanâ€ as the numberÂ 1Â to save memory.\n\n$ year : int [1:1704]:\n\nint:Â Integer. Whole numbers only.\n[1:1704]: This column is a vector with indices ranging from 1 to 1,704.\n\n$ lifeExp : num:\n\nnum:Â Numeric. This is a â€œdoubleâ€ or decimal number. This is what you use for most statistical calculations.\n\n\n\n\nIn which years has the GDP of Canada been larger than the average of all data points?\n\ncanada&lt;-gapminder[gapminder$country==\"Canada\",]\nmgdp&lt;-mean(canada$gdpPercap)\ncanada[canada$gdpPercap&gt;mgdp,\"year\"]\n\nFind the mean life expectancy of Switzerland before and after 2000\n\nswiss&lt;-gapminder[gapminder$country==\"Switzerland\",]\nmean(swiss[swiss$year&lt;2000,]$lifeExp) # Before\nmean(swiss[swiss$year&gt;2000,]$lifeExp) # After\n\nYou discovered that all the entries from 2007 are actually from 2008. Create a copy of the full gapminder data frame in an object called gp. Then change the year column to correct the entries from 2007.\n\ngp&lt;-gapminder\ngp[gp$year==2007,\"year\"]&lt;-2008\ngp[gp$year==2008,]\n\nBonus - Find the mean life expectancy and mean gdp per continent using the function tapply\n\ntapply(gapminder$lifeExp,gapminder$continent,mean)",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼’"
    ]
  },
  {
    "objectID": "WebsiteCodes/Setup.html",
    "href": "WebsiteCodes/Setup.html",
    "title": "Getting Started: Installing R and RStudio",
    "section": "",
    "text": "Note\n\n\n\nR and RStudio are two different programs that work together. R is the programming language and RStudio is a front end program that lets you write R code, view plots, etc.\nTo understand the difference, think of the relationship between a carâ€™s engine and its dashboard:\n\nR is the Engine: It is the powerful machine under the hood. It does all the heavy lifting, makes the car move, and handles the energy. But on its own, an engine is just a block of metal on the floorâ€”you canâ€™t sit in it or steer it easily.\nRStudio is the Dashboard: Itâ€™s the steering wheel, the seats, the GPS, and the speedometer. Itâ€™s the beautiful interface that lets you interact with the engine so you can actually drive where you want to go.\n\nKey Takeaway: Each program must be downloaded separately. You need to install both programs on your computer, but you will only ever â€œopenâ€ RStudio to do your work.",
    "crumbs": [
      "Installing R and RStudio"
    ]
  },
  {
    "objectID": "WebsiteCodes/Setup.html#install-r-and-rstudio-for-mac",
    "href": "WebsiteCodes/Setup.html#install-r-and-rstudio-for-mac",
    "title": "Getting Started: Installing R and RStudio",
    "section": "1. Install R and RStudio for Mac",
    "text": "1. Install R and RStudio for Mac\n\n1.1 Install R\n\na) To install R, go to cran.r-project.org.\n\n\n\n\n\n\n\nb) Click Download R for (Mac) OS X.\n\n\n\n\n\n\n\nc) Check the Latest release: section for the appropriate version and follow the directions for download.\n\n\n\n\n\n\n\n\n\n\n\n\nTipFind out which macOS your Mac is using\n\n\n\nTo ensure you download the correct version of R, you need to check which processor your Mac uses:\n\nClick the Apple menu (ï£¿) in the top-left corner of your screen and select About This Mac.\nIn the window that appears, look for the Chip or Processor section:\n\nApple Silicon: If you see â€œChipâ€ followed by M1, M2, or M3, download the version for Apple silicon Macs.\nIntel: If you see â€œProcessorâ€ followed by Intel Core i5 or i7, download the version for Older Intel Macs.\n\n\nNote: The appearance of this window may vary depending on your macOS version, but the chip information will always be listed there.\n\n\n\n\n\n\n\n\nd) Once the file download is complete, click to open the installer in your Downloads folder. Click Continue and proceed through the installer.\n\n\n\n\n\n\n\ne) Once the R installer has finished, click Close.\n\n\n\n\n\n\n\n\n1.2 Install R Studio\n\na) Next, download RStudio. Go to https://posit.co/downloads/\n\n\nb) Click Download RStudio.\n\n\n\n\n\n\n\nc) Select the RStudio version compatible with your macOS.\nNote: If you are using macOS 13 (Ventura) or earlier, you may be redirected to an older version of RStudio that is optimized for your specific operating system.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipFind out which macOS version your Mac is using\n\n\n\nTo ensure you download the correct version of R, you need to check which processor your Mac uses:\n\nClick the Apple menu (ï£¿) in the top-left corner of your screen and select About This Mac.\nIn the window that appears, look for the macOS section:\n\nThe number following the macOS name is your version number.\nExample: If your screen shows macOS Tahoe 25.0 (as seen in the figure below), your version is 25.\nAction: In this case, you should choose the download option macOS 14+ (macOS 14 and higher).\n\n\n\n\n\n\n\n\n\n\nd) Once the file download is complete, click to open the installer. Drag RStudio into your applications folder.\n\n\n\n\n\n\n\ne) Once the installation is complete, R and RStudio will open.",
    "crumbs": [
      "Installing R and RStudio"
    ]
  },
  {
    "objectID": "WebsiteCodes/Setup.html#install-r-and-rstudio-for-windows",
    "href": "WebsiteCodes/Setup.html#install-r-and-rstudio-for-windows",
    "title": "Getting Started: Installing R and RStudio",
    "section": "2. Install R and RStudio for Windows",
    "text": "2. Install R and RStudio for Windows\n\n2.1 Install R\n\na) To install R, go to cran.r-project.org.\n\n\n\n\n\n\n\nb) Choose for Download R for Windows.\n\n\n\n\n\n\n\nc) Install R Click on install R for the first time.\n\n\n\n\n\n\n\nd) Click Download R for Windows. Open the downloaded file.\n\n\n\n\n\n\n\ne) Select the language you would like to use during the installation. Then click OK.\n\n\n\n\n\n\n\n\n\n\n\n\nTipLanguage Recommendation: Why we suggest English\n\n\n\nWhile RStudio supports multiple languages, I highly recommend setting your environment to English. Here is why:\n\nEasier Troubleshooting: Most R documentation, forums, and Stack Overflow solutions are in English. When you encounter an error message, it is much easier to â€œGoogleâ€ the exact text to find a solution.\nEncoding Issues: If you use non-alphabetic languages (like Mandarin), you may run into â€œtext recognitionâ€ or encoding errors. This can result in â€œnonsenseâ€ characters (mojibake) in your console or error messages, making them impossible to read.\nConsistency: Most R packages and functions are named using English verbs, so keeping your interface in the same language makes the logic flow more naturally.\n\nDonâ€™t worry if youâ€™ve already chosen another language. You can usually change these settings later in the RStudio Global Options. In the absolute worst-case scenario, you can simply reinstall R, but for now, feel free to proceed with whichever language you are most comfortable with!\n\n\n\nf) Click Next.\n\n\n\n\n\n\n\ng) Select where you would like R to be installed. It will default to your Program Files on your C Drive. Click Next.\n\n\n\n\n\n\n\nh) You can then choose which installation you would like.\n\n\n\n\n\n\n\ni) (Optional) If your computer is a 64-bit, you can choose the 64-bit User Installation. Then click Next.\n\n\n\n\n\n\n\n\n\n\n\n\nTipHow can I tell if my Windows device is running a 32-bit or a 64-bit version of Windows?\n\n\n\nMost modern computers run the 64-bit version. Note that Windows 11 is 64-bit only, so if you have Windows 11, you are already set!\nTo confirm your system type on Windows 10 or 11:\n\nSelect the Start button and go to Settings &gt; System &gt; About.\nLocate the Device specifications section.\nLook next to System type:\n\n64-bit operating system, x64-based processor: Choose the 64-bit download.\n32-bit operating system, x86-based processor: Choose the 32-bit download (rare for newer machines).\n\n\n\n\n\n\n\n\n\n\nj) Then specify if you want to customized your startup or just use the defaults. Then click Next.\n\n\n\n\n\n\n\nk) Then you can choose the folder that you want R to be saved within or the default if the R folder that was created. Once you have finished, click Next.\n\n\n\n\n\n\n\nl) You can then select additional shortcuts if you would like. Click Next.\n\n\n\n\n\n\n\nm) Click Finish.\n\n\n\n\n\n\n\n\n2.2 Install RStudio\n\na) Next, download RStudio. Go to https://posit.co/downloads/\n\n\n\n\n\n\n\nb) Click Download RStudio.\n\n\n\n\n\n\n\nc) Once the packet has downloaded, the Welcome to RStudio Setup Wizard will open. Click Next and go through the installation steps.\n\n\n\n\n\n\n\nd) After the Setup Wizard finishing the installation, RStudio will open.",
    "crumbs": [
      "Installing R and RStudio"
    ]
  },
  {
    "objectID": "WebsiteCodes/Setup.html#notes",
    "href": "WebsiteCodes/Setup.html#notes",
    "title": "Getting Started: Installing R and RStudio",
    "section": "3. Notes",
    "text": "3. Notes\n\n3.1 Language Recommendation: Why we suggest English\n\n\n\n\n\n\nTipLanguage Recommendation: Why we suggest English\n\n\n\nWhile RStudio supports multiple languages, I highly recommend setting your environment to English. Here is why:\n\nEasier Troubleshooting: Most R documentation, forums, and Stack Overflow solutions are in English. When you encounter an error message, it is much easier to â€œGoogleâ€ the exact text to find a solution.\nEncoding Issues: If you use non-alphabetic languages (like Mandarin), you may run into â€œtext recognitionâ€ or encoding errors. This can result in â€œnonsenseâ€ characters (mojibake) in your console or error messages, making them impossible to read.\nConsistency: Most R packages and functions are named using English verbs, so keeping your interface in the same language makes the logic flow more naturally.\n\nDonâ€™t worry if youâ€™ve already chosen another language. You can usually change these settings later in the RStudio Global Options. In the absolute worst-case scenario, you can simply reinstall R, but for now, feel free to proceed with whichever language you are most comfortable with!",
    "crumbs": [
      "Installing R and RStudio"
    ]
  },
  {
    "objectID": "WebsiteCodes/QLS_MiCM.html",
    "href": "WebsiteCodes/QLS_MiCM.html",
    "title": "QLS-MiCM",
    "section": "",
    "text": "Mission statement: deliver quality workshops designed to help biomedical researchers develop the skills they need to succeed.\n\n\nContact: workshop-micm@mcgill.ca\n\n\n\n\nLocation: 550 Sherbrooke West, Montreal, Quebec\n\n\n\n\n\n\nScan the QR code to sign up for our mailing list\n\n\n\n\n\nMore Workshops\n\nhttps://www.mcgill.ca/micm/training/workshops-series\n\n\n\n\n\nThe following is a list of QLS-MiCM workshops offered in the previous year:\n\nHow to think in Code\nIntro to Git & GitHub\nIntro to Unix\nIntro to R (Part 1)\nStatistics in R (Part 2)\nIntro to Python (Part 1)\nIntermediate Python (Part 2)\nIntro to MATLAB\nRNA-seq Bootcamp (DNA2RNA || CDSI)\nData Processing in Python\nIntro to Machine Learning\nIntro to Molecular Simulations\nProteogenomics\nData Processing for Genetics\nPolygenic Risk Scores",
    "crumbs": [
      "QLS-MiCM"
    ]
  },
  {
    "objectID": "WebsiteCodes/Overview3.html#basic-data-manipulation",
    "href": "WebsiteCodes/Overview3.html#basic-data-manipulation",
    "title": "Overview: Basic and Advanced Data Manipulation",
    "section": "Basic Data Manipulation",
    "text": "Basic Data Manipulation\nBy the end of this module, you will be able to:\n\nImport and Export Data: Read from and write to common file formats (e.g., .csv, .tsv, and .txt) using functions like read.csv() and write.table().\nNavigate Data Frames: Utilize foundational functions (dim(), str(), head()) to assess the dimensions and structure of any dataset.\nMaster Base R Subsetting: Pinpoint specific data using the coordinate system [row, column], the $ operator, and logical indexing with which().\nModify Columns: Add, rename, or transform individual columns using standard assignment logic.\nMerge Datasets: Combine tables horizontally and vertically using cbind() and rbind().",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "Overview"
    ]
  },
  {
    "objectID": "WebsiteCodes/Overview3.html#advanced-data-manipulation",
    "href": "WebsiteCodes/Overview3.html#advanced-data-manipulation",
    "title": "Overview: Basic and Advanced Data Manipulation",
    "section": "Advanced Data Manipulation",
    "text": "Advanced Data Manipulation\nBy the end of this module, you will be able to:\n\nApply the dplyr Grammar: Efficiently manipulate data using core â€œverbsâ€ such as filter(), select(), mutate(), arrange(), and summarize().\nConstruct Pipelines: Use the pipe operator (%&gt;%) to chain multiple operations into a single, readable workflow.\nPerform Grouped Analyses: Use group_by() in combination with summarize() to calculate statistics (like mean or standard deviation) across different experimental cohorts.\nReshape Data: Convert between â€œwideâ€ and â€œlongâ€ formats using tidyr functions (pivot_longer, pivot_wider) to prepare data for visualization.\nIntegrate External Packages: Install and load specialized libraries to extend Râ€™s data manipulation capabilities.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "Overview"
    ]
  },
  {
    "objectID": "WebsiteCodes/Overview.html",
    "href": "WebsiteCodes/Overview.html",
    "title": "Overview: Data types and Data Structures",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDistinguish between objects, classes, and data types.\nCreate and manipulate the four primary atomic data types in R.\nIdentify the differences between vectors, lists, and data frames.\nAccess specific data using 1-based indexing and subsetting.\nApply vectorized operations to perform calculations on entire datasets at once.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "Overview"
    ]
  },
  {
    "objectID": "WebsiteCodes/Overview.html#learning-objectives",
    "href": "WebsiteCodes/Overview.html#learning-objectives",
    "title": "Overview: Data types and Data Structures",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nDistinguish between objects, classes, and data types.\nCreate and manipulate the four primary atomic data types in R.\nIdentify the differences between vectors, lists, and data frames.\nAccess specific data using 1-based indexing and subsetting.\nApply vectorized operations to perform calculations on entire datasets at once.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "Overview"
    ]
  },
  {
    "objectID": "WebsiteCodes/Overview.html#overview-of-operators-type",
    "href": "WebsiteCodes/Overview.html#overview-of-operators-type",
    "title": "Overview: Data types and Data Structures",
    "section": "Overview of Operators Type",
    "text": "Overview of Operators Type\nOperators are symbols or keywords that instruct R to perform specific mathematical, logical, or relational manipulations on data. The values that these operators act upon are called operands.\nFor example, in the expression x + 5: * The + is the Operator. * x and 5 are the Operands.\nKey Types of Operators in R include:\n\n1. Arithmetic Operators\nUsed to perform mathematical calculations.\n+ (Addition), - (Subtraction), * (Multiplication), / (Division).\n^ (Exponent/Power).\n%% (Modulus: returns the remainder of a division).\nâ€¦\n\n\n2. Assignment Operators\nUsed to store values inside objects.\n&lt;- (The â€œLeft Arrowâ€ assignment operator): This is the standard in R.\n= (Equals assignment): Works in many cases but is less common in the R community.\n\n\n3. Comparison (Relational) Operators\nUsed to compare two values. These always return a Logical result (TRUE or FALSE).\n== (Exactly equal to).\n!= (Not equal to).\n&lt;, &gt;, &lt;=, &gt;= (Less than, greater than, etc.).\n\n\n4. Logical Operators\nUsed to combine multiple comparison statements.\n& (AND): Returns TRUE if both sides are true.\n| (OR): Returns TRUE if at least one side is true.\n! (NOT): Reverses the logical state (TRUE becomes FALSE).\n\n\n5. Miscellaneous Operators\nMiscellaneous operators are used to manipulate data: The Colon Operator (:); The Membership Operator (%in%); The Dollar Sign Operator ($); The Pipe Operator (|&gt;) and (%&gt;%).",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "Overview"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise4.html",
    "href": "WebsiteCodes/Exercise4.html",
    "title": "Hands-on Exercise",
    "section": "",
    "text": "Use the covid_testing data set and everything youâ€™ve learned so far to answer the following questions:",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼”"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise4.html#clinics-included",
    "href": "WebsiteCodes/Exercise4.html#clinics-included",
    "title": "Hands-on Exercise",
    "section": "Clinics included",
    "text": "Clinics included\nHow many clinics participated in the study, and how many valid tests were performed on each one? Did the testing trend vary over time?\n\nNumber of clinics\n\n\nNumber of valid tests\n\n\nTesting trend over time",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼”"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise4.html#number-of-positive-tests",
    "href": "WebsiteCodes/Exercise4.html#number-of-positive-tests",
    "title": "Hands-on Exercise",
    "section": "Number of positive tests",
    "text": "Number of positive tests\nHow many patients tested positive vs negative in the first 100 days of the pandemic? Do you notice any difference with the age of the patients? Hint: You can make two age groups and calculate the percentage each age group in positive vs negative tests.\n\nNumber of positive tests in the first 100 days\n\n\nTests by age group",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼”"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise4.html#processing-times",
    "href": "WebsiteCodes/Exercise4.html#processing-times",
    "title": "Hands-on Exercise",
    "section": "Processing times",
    "text": "Processing times\nLook at the specimen processing time to receipt, did the sample processing times improve over the first 100 days of the pandemic? Plot the median processing times of each day over the course of the pandemic and then compare the summary statistics of the first 50 vs the last 50 days",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼”"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise4.html#bonus---viral-load",
    "href": "WebsiteCodes/Exercise4.html#bonus---viral-load",
    "title": "Hands-on Exercise",
    "section": "Bonus - Viral load",
    "text": "Bonus - Viral load\nHigher viral loads are detected in less PCR cycles.\nWhat can you observe about the viral load of positive vs negative samples.\nDo you notice anything differences in viral load across ages in the positive samples?\nHint: Also split the data into two age groups and try using geom_boxplot()",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼”"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise2.html",
    "href": "WebsiteCodes/Exercise2.html",
    "title": "Hands-on Exercise: Basic Data Manipulation",
    "section": "",
    "text": "library(gapminder)",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼’"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise2.html#writing-data",
    "href": "WebsiteCodes/Exercise2.html#writing-data",
    "title": "Hands-on Exercise: Basic Data Manipulation",
    "section": "Writing data",
    "text": "Writing data\nWrite a data processing snippet to include only the data points collected after 1995 in Asian countries as a CSV file\nSeparate the gapminder data frame into 5 individual data frames, one for each continent. Store those 5 data frames as an RData file in the objects folder called continents.RData.",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼’"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise2.html#exploring-data-frames",
    "href": "WebsiteCodes/Exercise2.html#exploring-data-frames",
    "title": "Hands-on Exercise: Basic Data Manipulation",
    "section": "Exploring data frames",
    "text": "Exploring data frames\nFinish exploring the gapminder data frame and:\n\nFind the number of rows and the number of columns\n\nPrint the data type of each column\n\nExplain the meaning of everything that str(gapminder) prints\n\nIn which years has the GDP of Canada been larger than the average of all data points?\nFind the mean life expectancy of Switzerland before and after 2000\nYou discovered that all the entries from 2007 are actually from 2008. Create a copy of the full gapminder data frame in an object called gp. Then change the year column to correct the entries from 2007.\nBonus - Find the mean life expectancy and mean gdp per continent using the function tapply",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼’"
    ]
  },
  {
    "objectID": "WebsiteCodes/ConcludingRemarks.html#what-we-learned-today",
    "href": "WebsiteCodes/ConcludingRemarks.html#what-we-learned-today",
    "title": "Concluding Remarks ğŸ‰",
    "section": "1. What We Learned Today",
    "text": "1. What We Learned Today\nWe have covered the foundational pillars of R programming for bioinformatics:\n\nThe Ecosystem: Understanding the difference between Base R, RStudio, CRAN, BioConductor, and GitHub.\nThe Basics: Mastering data types (vectors, factors, lists) and the â€œhome baseâ€ of the Working Directory.\nData Wrangling: Using dplyr verbs and the Pipe (%&gt;%) to turn messy spreadsheets into clean tables without creating intermediate â€œclutter.â€\nVisualization: Moving beyond basic plots to the layered â€œGrammar of Graphicsâ€ in ggplot2.\nReproducibility: Learning how to write robust functions and manage project scripts.",
    "crumbs": [
      "Concluding RemarksğŸ‰"
    ]
  },
  {
    "objectID": "WebsiteCodes/ConcludingRemarks.html#whats-next",
    "href": "WebsiteCodes/ConcludingRemarks.html#whats-next",
    "title": "Concluding Remarks ğŸ‰",
    "section": "2. Whatâ€™s Next?",
    "text": "2. Whatâ€™s Next?\nToday was about the mechanics of R. In the next stage, we move toward interpretation.\n\nStatistics in R Workshop (Part 2)\n\nData Wrangling: Advanced joining of datasets (merging clinical data with genomic counts).\nStatistical Analysis: Performing T-tests, ANOVA, and correlation studies.\nRegression: Building linear models to understand the relationship between variables.\nReporting: Using Quarto to create automated PDF or HTML reports for your PI.",
    "crumbs": [
      "Concluding RemarksğŸ‰"
    ]
  },
  {
    "objectID": "WebsiteCodes/ConcludingRemarks.html#resources-for-continued-r-learning",
    "href": "WebsiteCodes/ConcludingRemarks.html#resources-for-continued-r-learning",
    "title": "Concluding Remarks ğŸ‰",
    "section": "3. Resources for Continued R Learning",
    "text": "3. Resources for Continued R Learning\nAs you continue your R study, these resources will be your best friends:\n\nBioconductor Tutorials\nR Cheat Sheets\n\n\n\nR for Data Science (2e)\nR Graphics Cookbook, 2nd edition\nR in Action, Second Edition\nHands-On Programming with R\nThe Epidemiologist R Handbook\nR for Non-Programmers: A Guide for Social Scientists\nCodecademy: Learn R Free Course: Good for those who prefer an interactive, â€œin-browserâ€ coding experience to practice syntax.\nMcGill CDSI Workshops: Our colleagues at the Computational and Data Systems Institute offer excellent deep-dives into specific data topics.\nMcGill QLS-MiCM Workshops: Keep an eye on future MiCM workshops for specialized bioinformatics and high-performance computing training.",
    "crumbs": [
      "Concluding RemarksğŸ‰"
    ]
  },
  {
    "objectID": "WebsiteCodes/ConcludingRemarks.html#more-workshops",
    "href": "WebsiteCodes/ConcludingRemarks.html#more-workshops",
    "title": "Concluding Remarks ğŸ‰",
    "section": "4. More workshops",
    "text": "4. More workshops\n\nhttps://www.mcgill.ca/micm/training/workshops-series\n\n\n\n\n\nThe following is a list of QLS-MiCM workshops offered in the previous year:\n\nHow to think in Code\nIntro to Git & GitHub\nIntro to Unix\nIntro to R (Part 1)\nStatistics in R (Part 2)\nIntro to Python (Part 1)\nIntermediate Python (Part 2)\nIntro to MATLAB\nRNA-seq Bootcamp (DNA2RNA || CDSI)\nData Processing in Python\nIntro to Machine Learning\nIntro to Molecular Simulations\nProteogenomics\nData Processing for Genetics\nPolygenic Risk Scores",
    "crumbs": [
      "Concluding RemarksğŸ‰"
    ]
  },
  {
    "objectID": "WebsiteCodes/ConcludingRemarks.html#thank-you-for-attending-feedback-form",
    "href": "WebsiteCodes/ConcludingRemarks.html#thank-you-for-attending-feedback-form",
    "title": "Concluding Remarks ğŸ‰",
    "section": "5. Thank you for attending! & Feedback Form",
    "text": "5. Thank you for attending! & Feedback Form\nYou are welcome to scan the QR code below or just click here to share your feedback on todayâ€™s workshop. Any suggestions for improvement are warmly welcome!",
    "crumbs": [
      "Concluding RemarksğŸ‰"
    ]
  },
  {
    "objectID": "WebsiteCodes/13Graphics.html#graphics-with-base-r",
    "href": "WebsiteCodes/13Graphics.html#graphics-with-base-r",
    "title": "Generating Visual Outputs",
    "section": "1. Graphics with Base R",
    "text": "1. Graphics with Base R\nBase R is great for a â€œquick lookâ€ at your data. It is fast because it doesnâ€™t require any extra libraries, but it can be difficult to customize once your plots get complex.\n\nSimple Histogram\n\nif (!require(\"gapminder\", quietly = TRUE))\n    install.packages(\"gapminder\")\nlibrary(gapminder)\n\nhist(gapminder$lifeExp, \n     xlab = \"Life expectancy\", \n     main = \"Histogram of Life Expectancy\", \n     col  = \"lightblue\")\n\n\n\n\n\n\n\n\n\n\nMulti-panel Plots with par()\nIf you want to see multiple variables at once (e.g., for Switzerland), you can use par(mfrow = c(rows, cols)) to divide your plotting window.\n\ndf_swiss &lt;- gapminder[gapminder$country == \"Switzerland\", ]\npar(mfrow = c(1, 3)) # 1 row, 3 columns\n\nplot(y = df_swiss$lifeExp, x = df_swiss$year, xlab = \"Years\", ylab = \"Life expectancy\", type = \"b\")\nplot(y = df_swiss$pop, x = df_swiss$year, xlab = \"Years\", ylab = \"Population size\", type = \"b\")\nplot(y = df_swiss$gdpPercap, x = df_swiss$year, xlab = \"Years\", ylab = \"GDP per capita\", type = \"b\")",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Generating Visual Outputs",
      "ğŸ­ğŸ¯ Graphics"
    ]
  },
  {
    "objectID": "WebsiteCodes/13Graphics.html#graphics-with-ggplot2",
    "href": "WebsiteCodes/13Graphics.html#graphics-with-ggplot2",
    "title": "Generating Visual Outputs",
    "section": "2. Graphics with ggplot2",
    "text": "2. Graphics with ggplot2\nggplot2 is based on the Grammar of Graphics. Instead of thinking about â€œplots,â€ we think about layers:\n\nData: The dataframe you are using.\nAesthetics (aes): Mapping data columns to visual properties (x, y, color, size).\nGeometries (geom): The visual marks (points, lines, bars).\n\n\nComparing Multiple Countries\n\nif (!require(\"ggplot2\", quietly = TRUE))\n    install.packages(\"ggplot2\")\nlibrary(ggplot2)\nif (!require(\"dplyr\", quietly = TRUE))\n    install.packages(\"dplyr\")\nlibrary(dplyr)\n\ndf_subset &lt;- gapminder %&gt;%\n      dplyr::filter(country %in% c(\"Switzerland\", \"Australia\", \"Zimbabwe\", \"India\"))\n      \nggplot(df_subset, aes(x = year, y = lifeExp, color = country)) +\n  geom_point() +\n  geom_line() +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe Layering Rule: Why Order Matters\nBecause ggplot2 builds plots layer-by-layer, objects drawn later can cover up objects drawn earlier. This is most obvious when combining bars and error bars.\nExample: Bar Plot vs.Â Error Bars\nLetâ€™s look at what happens when we switch the order of geom_col() (the bars) and geom_errorbar().\nOption A: Error Bars on Top\nIn this version, we draw the bars first, then â€œpaintâ€ the error bars on top. They are fully visible.\n\n# 1. Prepare summary data\ndf_summary &lt;- gapminder %&gt;%\n  filter(continent == \"Americas\") %&gt;%\n  group_by(country) %&gt;%\n  summarize(mean_le = mean(lifeExp), sd_le = sd(lifeExp)) %&gt;%\n  slice_head(n = 5) # Just top 5 for clarity\n\n# 2. Plot: Bars THEN Error Bars\nggplot(df_summary, aes(x = country, y = mean_le)) +\n  geom_col(fill = \"skyblue\") + # Layer 1: The Bar\n  geom_errorbar(aes(ymin = mean_le - sd_le, ymax = mean_le + sd_le), \n                width = 0.2)   # Layer 2: On top of the bar\n\n\n\n\n\n\n\n\nOption B: Error Bars Underneath\nIf we draw the error bars first, the bar is painted over them. If your bar is solid (no transparency), half of your error bar disappears!\n\n# 3. Plot: Error Bars THEN Bars\nggplot(df_summary, aes(x = country, y = mean_le)) +\n  geom_errorbar(aes(ymin = mean_le - sd_le, ymax = mean_le + sd_le), \n                width = 0.2, linewidth = 2, color = \"red\") + # Layer 1: Underneath\n  geom_col(fill = \"skyblue\")\n\n\n\n\n\n\n\n\n\n\n\n\nThe â€œAll-in-Oneâ€ Pipeline\nOne of the best features of the Tidyverse is that you can pipe your data manipulation results directly into ggplot(). This avoids creating unnecessary intermediate objects in your environment.\n\ngapminder %&gt;%\n  dplyr::group_by(continent, year) %&gt;%\n  dplyr::summarize(mean_gdpPercap = mean(gdpPercap)) %&gt;%\n  ggplot(aes(x = year, y = mean_gdpPercap, color = continent)) +\n    geom_point() +\n    geom_line() +\n    labs(title = \"Mean GDP per Capita by Continent\", y = \"Mean GDP\")",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Generating Visual Outputs",
      "ğŸ­ğŸ¯ Graphics"
    ]
  },
  {
    "objectID": "WebsiteCodes/13Graphics.html#advanced-ggplot2-tricks",
    "href": "WebsiteCodes/13Graphics.html#advanced-ggplot2-tricks",
    "title": "Generating Visual Outputs",
    "section": "3. Advanced ggplot2 Tricks",
    "text": "3. Advanced ggplot2 Tricks\n\nData Format (Wide vs.Â Long)\nggplot2 almost always expects data in Long Format (one column for the category, one column for the value). If your data is â€œWideâ€ (e.g., each year is its own column), you must tidy it first.\n\nWide Format: Each row is a unique subject (e.g., a patient), and each column is a different variable or time point. Great for Excel; bad for ggplot2.\nLong Format: Each row is a single observation. One column identifies the patient, one identifies the variable type, and one contains the value.\n\n\n\n\n\n\nThe functions tidyr::pivot_wider() and tidyr::pivot_longer() are very useful to transform one into the other.\nFor example:\n\nif (!require(\"tidyr\", quietly = TRUE))\n    install.packages(\"tidyr\")\nlibrary(tidyr)\n\ndf &lt;- data.frame(\n  patientID = c(\"P1\", \"P2\", \"P3\"),\n  BW = c(50, 64, 89),\n  BG = c(6.1, 5.4, 7.9)\n)\n\n# Transform to Long Format\ndf_long &lt;- df %&gt;% \n  tidyr::pivot_longer(\n    cols = c(BW, BG),      # Columns you want to \"melt\"\n    names_to = \"measure\",   # Name for the new category column\n    values_to = \"value\"     # Name for the new data column\n  )\n\nprint(df_long)\n\n# A tibble: 6 Ã— 3\n  patientID measure value\n  &lt;chr&gt;     &lt;chr&gt;   &lt;dbl&gt;\n1 P1        BW       50  \n2 P1        BG        6.1\n3 P2        BW       64  \n4 P2        BG        5.4\n5 P3        BW       89  \n6 P3        BG        7.9\n\n\n\nggplot(df_long, aes(x = patientID, y = value, fill = measure)) +\n  geom_col(position = \"dodge\") +\n  facet_wrap(~measure, scales = \"free_y\") +\n  theme_minimal() +\n  labs(title = \"Clinical Metrics by Patient\",\n       y = \"Measurement Value\",\n       x = \"Patient ID\")\n\n\n\n\n\n\n\n\n\n\nControlling Colors & Factors\nIf you want your legend to appear in a specific order (e.g., descending wealth), you must modify the Levels of your factor.\n\ngapminder %&gt;%\n  dplyr::group_by(continent, year) %&gt;%\n  dplyr::mutate(continent = factor(as.character(continent), \n                                   levels = c(\"Oceania\", \"Europe\", \"Americas\", \"Asia\", \"Africa\"))) %&gt;%\n  dplyr::summarize(mean_gdpPercap = mean(gdpPercap)) %&gt;%\n  ggplot(aes(x = year, y = mean_gdpPercap, color = continent)) +\n    geom_line(linewidth = 1) +\n    scale_color_viridis_d() # Uses a colorblind-friendly palette\n\n\n\n\n\n\n\n\n\n\nLayering on Top of the Object\nYou can store the plots in an object and keep adding layers to it.\n\np &lt;- gapminder %&gt;% \n  group_by(continent, year) %&gt;% \n  # Set the order of the legend manually\n  mutate(continent = factor(continent, levels = c(\"Oceania\", \"Europe\", \"Africa\", \"Americas\", \"Asia\"))) %&gt;% \n  summarize(mean_gdpPercap = mean(gdpPercap)) %&gt;% \n  ggplot(aes(x = year, y = mean_gdpPercap, color = continent)) + \n    geom_point() + \n    geom_line()\n\n# Use the viridis discrete scale\np + scale_color_viridis_d(begin = 0.1, end = 0.8) +\n    theme_bw() + \n    labs(title = \"GDP Growth by Continent\", \n         subtitle = \"Customized using the 'p' object\",\n         color = \"Continent Name\")",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Generating Visual Outputs",
      "ğŸ­ğŸ¯ Graphics"
    ]
  },
  {
    "objectID": "WebsiteCodes/13Graphics.html#creating-publication-ready-figures",
    "href": "WebsiteCodes/13Graphics.html#creating-publication-ready-figures",
    "title": "Generating Visual Outputs",
    "section": "4. Creating Publication-Ready Figures",
    "text": "4. Creating Publication-Ready Figures\nA â€œpublication-readyâ€ figure isnâ€™t just one that looks good; itâ€™s one that is legible, accurate, and accessible.\nWe will use the ggprism package to give our plot a clean, professional â€œhigh-end journalâ€ aesthetic.\nNotice how we combine all the tricks weâ€™ve learned: manual scales, modulo logic for axes, and theme customization.\n\nif (!require(\"ggprism\", quietly = TRUE))\n    install.packages(\"ggprism\")\nlibrary(ggprism)\n\n# 1. Prepare Data with Standard Error\nplot_data &lt;- gapminder %&gt;% \n  group_by(continent, year) %&gt;% \n  mutate(continent = factor(continent, levels = c(\"Africa\", \"Americas\", \"Asia\", \"Europe\", \"Oceania\"))) %&gt;% \n  summarize(\n    mean_gdpPercap = mean(gdpPercap),\n    se_gdpPercap = sd(gdpPercap) / sqrt(n()),\n    .groups = \"drop\" # Good practice to ungroup after summarizing\n  )\n\n# 2. Build the Figure\nggplot(plot_data, \n       aes(x = year, y = mean_gdpPercap, color = continent)) +\n  \n  # Lines and Error Bars\n  geom_line(linewidth = 1) +\n  geom_errorbar(aes(ymin = mean_gdpPercap, \n                    ymax = mean_gdpPercap + se_gdpPercap),\n                width = 1.5, linewidth = 1) +\n  \n  # Points with fillable shapes (21-25)\n  geom_point(aes(shape = continent, fill = continent), size = 3) +\n  \n  # Manual Styling\n  scale_shape_manual(values = c(22, 21, 24, 23, 25)) +\n  scale_fill_manual(values = c(\"#ffd700\", \"#ffb14e\", \"#fa8775\", \"#ea5f94\", \"#9d02d7\")) +\n  scale_color_manual(values = c(\"#ffd700\", \"#ffb14e\", \"#fa8775\", \"#ea5f94\", \"#9d02d7\")) +\n  \n  # Axis Customization\n  scale_x_continuous(\n    breaks = seq(1950, 2010, 5), \n    labels = ifelse(seq(1950, 2010, 5) %% 10 == 0, seq(1950, 2010, 5), \"\")\n  ) +\n  scale_y_continuous(\n    breaks = seq(0, 35000, 5000), \n    labels = ifelse(seq(0, 35000, 5000) %% 10000 == 0, seq(0, 35000, 5000), \"\"),\n    limits = c(0, 35000), expand = c(0, 0)\n  ) +\n  \n  # Labels and Theme\n  labs(x = \"Year\", \n       y = \"GDP per Capita\", \n       fill = \"Continent\", \n       color = \"Continent\", \n       shape = \"Continent\") +\n  theme_prism() + \n  theme(\n    legend.title = element_text(size = 12, face = \"bold\"),\n    legend.text = element_text(size = 11, face = \"bold\"),\n    axis.title   = element_text(size = 11, face = \"bold\"),\n    axis.text    = element_text(size = 10),\n    axis.line = element_line(linewidth = 1),\n    axis.ticks = element_line(linewidth = 1),\n    axis.ticks.length = unit(0.15, \"cm\")\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhat makes this figure â€œAdvancedâ€?\n\ntheme_prism(): This instantly changes the tick marks and axis lines to be thicker and more pronounced, which is the standard â€œPrismâ€ look.\nColor Syncing: We mapped continent to color, fill, and shape. By ensuring the labels in the labs() function are all named the same (â€œContinentâ€), R merges them into one clean legend.\nVisual Breathing Room: By using ifelse on the labels, we keep the x-axis from becoming a crowded mess of numbers while still showing where the 5-year intervals sit.\nError Bars: In bioinformatics, showing the spread of data (SE or SD) is mandatory. Using geom_errorbar adds that layer of statistical trust to your figure.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Generating Visual Outputs",
      "ğŸ­ğŸ¯ Graphics"
    ]
  },
  {
    "objectID": "WebsiteCodes/13Graphics.html#resources-inspiration",
    "href": "WebsiteCodes/13Graphics.html#resources-inspiration",
    "title": "Generating Visual Outputs",
    "section": "5. Resources & Inspiration",
    "text": "5. Resources & Inspiration\nCreating a publication-ready figure is part science and part art. When you get stuck or need inspiration for a complex â€œprism-likeâ€ figure, these are the best places to look.\n\nğŸ“š Foundational Learning\n\nR for Data Science (2e)\nR Graphics Cookbook, 2nd edition\nThe R Graph Gallery\n\n\n\nğŸ”¬ Specialized Biomedical Tools\nThese resources are specifically designed for high-impact biological and medical journals (Nature, Science, Cell).\n\nFigureYa\nHiPlot\nMarsilea\nggalign Gallery\nBizard\n\n\n\nğŸ¨ Color & Style\n\nCNScolor\nScientific Color Palettes Guide\n\n\n\n\n\n\n\nNote\n\n\n\nTips for Troubleshooting\nWhen you canâ€™t get a plot to look exactly right:\n\nBe Specific with AI: Donâ€™t just ask â€œHow do I make a bar plot?â€ Ask: â€œIn R ggplot2, how do I change the legend title size and reorder the x-axis factors?â€\nThe â€œCheat Sheetâ€ Search: Search Google Images for â€œggplot2 cheat sheetâ€. Keep a printed copy of the official Posit Cheat Sheet on your desk.\nCheck the â€œGeomâ€: If the plot looks weird, 90% of the time itâ€™s because the data isnâ€™t in the Long Format we discussed in Section 3.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Generating Visual Outputs",
      "ğŸ­ğŸ¯ Graphics"
    ]
  },
  {
    "objectID": "WebsiteCodes/11AdvDataFrames.html#adding-columns-and-rows",
    "href": "WebsiteCodes/11AdvDataFrames.html#adding-columns-and-rows",
    "title": "Exploring Data Frames",
    "section": "1. Adding Columns and Rows",
    "text": "1. Adding Columns and Rows\nWe will still use the gapminder dataset as demo dataste.\n\n# Dataset Preparation\nif (!require(\"gapminder\", quietly = TRUE))\n    install.packages(\"gapminder\")\nlibrary(gapminder)\n\naust &lt;- gapminder[gapminder$country == \"Australia\",]\nhead(aust)\n## # A tibble: 6 Ã— 6\n##   country   continent  year lifeExp      pop gdpPercap\n##   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n## 1 Australia Oceania    1952    69.1  8691212    10040.\n## 2 Australia Oceania    1957    70.3  9712569    10950.\n## 3 Australia Oceania    1962    70.9 10794968    12217.\n## 4 Australia Oceania    1967    71.1 11872264    14526.\n## 5 Australia Oceania    1972    71.9 13177000    16789.\n## 6 Australia Oceania    1977    73.5 14074100    18334.\ndim(aust)\n## [1] 12  6\n\n\n1.1 Individually Adding Columns\nYou can add a new column by simply assigning values to a name that doesnâ€™t exist yet using the $ operator or bracket [ , ] notation.\n\n\n\n\n\n\nImportant\n\n\n\nCrucial Rule: The new column must have the exact same number of rows as the existing data frame.\n\n\n\nMethod A: Using the $ operator\n\n# Method A: Using the $ operator\n# Adding a random column for \"mean_children\"\nmean_children &lt;- sample(1:10, nrow(aust), replace = TRUE)\naust$mean_children &lt;- mean_children\n# the same as: aust$mean_children &lt;- sample(1:10, nrow(aust), replace = TRUE)\n\n# Adding a calculated column (GDP = population * GDP per capita)\naust$GDP &lt;- aust$pop * aust$gdpPercap\n\nhead(aust)\n\n# A tibble: 6 Ã— 8\n  country   continent  year lifeExp      pop gdpPercap mean_children         GDP\n  &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;         &lt;int&gt;       &lt;dbl&gt;\n1 Australia Oceania    1952    69.1  8691212    10040.             1     8.73e10\n2 Australia Oceania    1957    70.3  9712569    10950.             9     1.06e11\n3 Australia Oceania    1962    70.9 10794968    12217.             6     1.32e11\n4 Australia Oceania    1967    71.1 11872264    14526.             6     1.72e11\n5 Australia Oceania    1972    71.9 13177000    16789.             2     2.21e11\n6 Australia Oceania    1977    73.5 14074100    18334.             2     2.58e11\n\n\n\n\n\n\n\n\nNote\n\n\n\nUnderstanding sample():\n\n1:10: The range of numbers to choose from.\nnrow(aust): Tells R exactly how many numbers to generate (12 in this case).\nreplace = TRUE: Allows the same number to be picked more than once.\n\n\n\n\n\nMethod B: Using bracket notation\n\n# Method B: Using bracket notation\nmean_bikes &lt;- sample(1:4, nrow(aust), replace = TRUE)\naust[, \"mean_bikes\"] &lt;- mean_bikes\n\nstr(aust)\n\ntibble [12 Ã— 9] (S3: tbl_df/tbl/data.frame)\n $ country      : Factor w/ 142 levels \"Afghanistan\",..: 6 6 6 6 6 6 6 6 6 6 ...\n $ continent    : Factor w/ 5 levels \"Africa\",\"Americas\",..: 5 5 5 5 5 5 5 5 5 5 ...\n $ year         : int [1:12] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 ...\n $ lifeExp      : num [1:12] 69.1 70.3 70.9 71.1 71.9 ...\n $ pop          : int [1:12] 8691212 9712569 10794968 11872264 13177000 14074100 15184200 16257249 17481977 18565243 ...\n $ gdpPercap    : num [1:12] 10040 10950 12217 14526 16789 ...\n $ mean_children: int [1:12] 1 9 6 6 2 2 2 3 4 5 ...\n $ GDP          : num [1:12] 8.73e+10 1.06e+11 1.32e+11 1.72e+11 2.21e+11 ...\n $ mean_bikes   : int [1:12] 2 4 1 1 2 4 2 2 2 2 ...\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhat happens if the lengths donâ€™t match?\nIf you try to â€œforceâ€ a vector into a table that is a different height, R will protect the integrity of your data and throw an error.\n\nmean_bikes &lt;- sample(1:4, 5, replace = TRUE)\naust[, \"mean_bikes\"] &lt;- mean_bikes\n\nError in `[&lt;-`:\n! Assigned data `mean_bikes` must be compatible with existing data.\nâœ– Existing data has 12 rows.\nâœ– Assigned data has 5 rows.\nâ„¹ Only vectors of size 1 are recycled.\nCaused by error in `vectbl_recycle_rhs_rows()`:\n! Can't recycle input of size 5 to size 12.\n\n\nWhy did this fail? R uses a concept called Recycling.\n\nIf you provide 1 value: R repeats it for every row (this is allowed).\nIf you provide 12 values: Itâ€™s a perfect fit (this is allowed).\nIf you provide 5 values: R doesnâ€™t know what to do with the remaining 7 rows, so it stops the code to prevent errors in your analysis.\n\nBest Practice: Use nrow()\nAlways use nrow(your_dataframe) instead of typing a specific number (like 12). If you later filter your data or add more patients, your code will automatically adjust the length of your new columns!\n\n\n\n\n\n1.2 Combining Data Frames by Columns\n\nMethod A: Using the cbind()\nIf you have a whole table of new data, you can â€œstapleâ€ it to the side of your original data using cbind() (column bind). Unlike adding columns one by one, cbind() allows you to merge two entire data frames into one.\n\naust &lt;- gapminder[gapminder$country == \"Australia\", ]\n# Create a separate data frame with two new variables\ndf &lt;- data.frame(mean_children = sample(1:10, nrow(aust), replace = TRUE),\n               mean_bikes = sample(1:4, nrow(aust), replace = TRUE))\nhead(df)\n##   mean_children mean_bikes\n## 1             9          4\n## 2             6          1\n## 3            10          2\n## 4             7          3\n## 5             6          1\n## 6             3          1\n\naust &lt;- cbind(aust,df)\nhead(aust)\n##     country continent year lifeExp      pop gdpPercap mean_children mean_bikes\n## 1 Australia   Oceania 1952   69.12  8691212  10039.60             9          4\n## 2 Australia   Oceania 1957   70.33  9712569  10949.65             6          1\n## 3 Australia   Oceania 1962   70.93 10794968  12217.23            10          2\n## 4 Australia   Oceania 1967   71.10 11872264  14526.12             7          3\n## 5 Australia   Oceania 1972   71.93 13177000  16788.63             6          1\n## 6 Australia   Oceania 1977   73.49 14074100  18334.20             3          1\n\n\n\n\n\n\n\nWarning\n\n\n\nâš ï¸ A Critical Warning: The Row Order\nWhile cbind() is powerful, it is also â€œblind.â€\nIt assumes that Row 1 of your first table belongs with Row 1 of your second table.\nIn medical research, this is very dangerous if your tables arenâ€™t sorted perfectly. If your first table has patients in the order P001, P002, P003 and your second table has them as P003, P001, P002, cbind() will mismatch the data!\nBest Practice: Use merge() or left_join()\nIf you arenâ€™t 100% sure the rows are in the same order, donâ€™t use cbind(). Instead, use merge() (Base R) or left_join()(dplyr). These functions look at an ID column (like a patient ID) and automatically align the rows for you.\n\n\n\n\nMethod B: Using the merge()\nTo avoid mismatching data, we use merge(). This function looks at a specific Key Column (like Patient_ID or country) and aligns the rows automatically, even if they are in a different order.\n\n# 1. Prepare a subset of data\ncountries &lt;- gapminder[gapminder$country %in% c(\"Taiwan\", \"Canada\"), ]\n\n# 2. Create a secondary table with a \"Key Column\" (country)\n# Note: This table could be in any order!\ndf_info &lt;- data.frame(\n  country = c(\"Canada\", \"Taiwan\"),\n  avg_coffee_price = c(4.50, 3.20)\n)\n\n# 3. Merge based on the \"country\" column\n# R will find where \"Taiwan\" is in both tables and match them up\ncountries_merged &lt;- merge(countries, df_info, by = \"country\")\n\nhead(countries_merged)\n\n  country continent year lifeExp      pop gdpPercap avg_coffee_price\n1  Canada  Americas 1952   68.75 14785584  11367.16              4.5\n2  Canada  Americas 1957   69.96 17010154  12489.95              4.5\n3  Canada  Americas 1962   71.30 18985849  13462.49              4.5\n4  Canada  Americas 1967   72.13 20819767  16076.59              4.5\n5  Canada  Americas 1972   72.88 22284500  18970.57              4.5\n6  Canada  Americas 1977   74.21 23796400  22090.88              4.5\n\n\n\n# 1. Prepare a subset of data\npatient_info &lt;- data.frame(\n  patientID = c(\"P1\", \"P2\", \"P3\", \"P100\"),\n  BW = c(50, 62, 73, 85)\n)\n\n# 2. Create a secondary table\npatient_BG &lt;- data.frame(\n  patientID = c(\"P1\", \"P100\", \"P3\", \"P2\"),\n  BG = c(7.1, 8.3, 9.5, 11)\n)\n\n# 3. Merge based on the \"country\" column\n# R will find where \"Taiwan\" is in both tables and match them up\ndata_merged &lt;- merge(patient_info, patient_BG, by = \"patientID\")\n\nhead(data_merged)\n\n  patientID BW   BG\n1        P1 50  7.1\n2      P100 85  8.3\n3        P2 62 11.0\n4        P3 73  9.5\n\n\n\n\n\n\n\n\nNote\n\n\n\nğŸ’¡ Why merge() is better than cbind()\n\nOrder Doesnâ€™t Matter: In the example above, df_info lists Canada first, but in the countries dataset, the rows might appear in a different order. merge() finds the match regardless of where the row is located.\nFlexible Lengths: Notice that countries has many years of data for each country, but df_info only has one price per country. merge() is smart enough to â€œbroadcastâ€ (repeat) that one coffee price across all the matching years for that country.\nPattern Matching: Instead of â€œmechanicallyâ€ pasting columns, merge() looks for a specific pattern (the country name). If a country in your first table isnâ€™t found in your second table, R can be told exactly how to handle that â€œmissingâ€ data.\n\n\n\n\n\n\n1.3 Adding Rows (rbind)\nAdding rows is slightly more complex because a row usually contains mixed data types (text, numbers, etc.).\n\n\n\n\n\n\nNote\n\n\n\nWhy use a list for a new row? A data frame is a list of vectors. A single row crosses those vectors, so it must be able to hold different types of data at once. A list is the perfect container for this.\n\n\n\naust &lt;- gapminder[gapminder$country == \"Australia\",]\n\n# Create a new row as a list\nnew_row &lt;- list(\n  \"country\" = \"Australia\",\n  \"continent\" = \"Oceania\",\n  \"year\" = 2022,\n  \"lifeExp\" = mean(aust$lifeExp),\n  \"pop\" = mean(aust$pop),\n  \"gdpPercap\" = mean(aust$gdpPercap)\n)\n\n# Append the row to the bottom\naust &lt;- rbind(aust, new_row)\n\ntail(aust)\n## # A tibble: 6 Ã— 6\n##   country   continent  year lifeExp       pop gdpPercap\n##   &lt;fct&gt;     &lt;fct&gt;     &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n## 1 Australia Oceania    1987    76.3 16257249     21889.\n## 2 Australia Oceania    1992    77.6 17481977     23425.\n## 3 Australia Oceania    1997    78.8 18565243     26998.\n## 4 Australia Oceania    2002    80.4 19546792     30688.\n## 5 Australia Oceania    2007    81.2 20434176     34435.\n## 6 Australia Oceania    2022    74.7 14649312.    19981.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "ğŸ­ğŸ­ Exploring Data Frames"
    ]
  },
  {
    "objectID": "WebsiteCodes/11AdvDataFrames.html#removing-and-filtering-data",
    "href": "WebsiteCodes/11AdvDataFrames.html#removing-and-filtering-data",
    "title": "Exploring Data Frames",
    "section": "2. Removing and Filtering Data",
    "text": "2. Removing and Filtering Data\n\n2.1 Removing Columns and Rows\nWe use negative indexing to drop data.\n\nMethod A: Removing by Index (Position)\nIf you know exactly where a column is located, you can drop it using its number.\n\naust &lt;- gapminder[gapminder$country == \"Australia\",]\ndim(aust)\n## [1] 12  6\ncolnames(aust)\n## [1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"\n\n# 1. Remove the LAST column dynamically\n# ncol(aust) finds the last number for you, so you don't have to count!\naust &lt;- aust[, -ncol(aust)]\ncolnames(aust)\n## [1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"\n\n# 2. Remove multiple specific columns (e.g., the 1st and 3rd)\naust &lt;- aust[, -c(1, 3)]\ncolnames(aust)\n## [1] \"continent\" \"lifeExp\"   \"pop\"\n\ndim(aust)\n## [1] 12  3\n\n\n\nMethod B: Removing by Name (The Safer Way)\nUsing numbers like -3 is risky because if your dataset changes, the 3rd column might become something else! It is safer to remove columns by their actual Name.\nYou ask R to keep every column except the one using the â€œNot Equal Toâ€ operator (!=).\n\n# Keep everything where the column name is NOT \"pop\"\ncolnames(aust)\n## [1] \"continent\" \"lifeExp\"   \"pop\"\naust &lt;- aust[, colnames(aust) != \"pop\"]\n\ncolnames(aust)\n## [1] \"continent\" \"lifeExp\"\n\n\n\nMethod C: Removing Rows\nThe logic for rows is the same: use a negative sign before the row indices.\n\n# Remove the first 10 rows\n# Both of these are correct; the first is the most professional standard\naust_reduced &lt;- aust[-c(1:10), ] \n## aust_reduced &lt;- aust[-(1:10), ]\n\ndim(aust_reduced)\n\n[1] 2 2\n\n\n\n\n\n2.2 Applying Filters (Logical Subsetting)\nFiltering (or subsetting) is how you â€œqueryâ€ your data to find specific samples or variables. In R, we use Logical Operators (like &gt;=, ==, or %in%) to tell R exactly what to keep.\n\nMethod A: Filtering Columns by Name\nIf you have a table with 20,000 genes but only want to see two specific ones, you can use the %in% operator.\n\naust &lt;- gapminder[gapminder$country == \"Australia\",]\n\n# Keep only the columns \"year\" and \"pop\"\n# which() identifies the position (index) of the names that match our list\naust_col &lt;- aust[ , which(colnames(aust) %in% c(\"year\", \"pop\"))]\n\ncolnames(aust_col)\n## [1] \"year\" \"pop\"\n\n\n\n\n\n\n\nNote\n\n\n\nWhy use which()?\nYou might notice that colnames(aust) %in% c(\"year\", \"pop\") returns a list of TRUE and FALSE. Wrapping it in which() converts those into actual numbers (the column positions), which is often safer and faster when dealing with very large datasets.\n\ncolnames(aust)\n## [1] \"country\"   \"continent\" \"year\"      \"lifeExp\"   \"pop\"       \"gdpPercap\"\n\ncolnames(aust) %in% c(\"year\", \"pop\")\n## [1] FALSE FALSE  TRUE FALSE  TRUE FALSE\n\nwhich(colnames(aust) %in% c(\"year\", \"pop\"))\n## [1] 3 5\n\n\n\n\n\nMethod B: Filtering Rows by Condition\nThis is where you ask R to find samples that meet a specific clinical or biological threshold.\n\naust &lt;- gapminder[gapminder$country == \"Australia\",]\n\n# 1. Filter by a fixed threshold\n# Keep only rows where Life Expectancy is 70 or higher\nlong_life &lt;- aust[aust$lifeExp &gt;= 70, ]\ndim(long_life)\n## [1] 11  6\n\n# 2. Filter by a calculated threshold\n# Keep only rows where GDP is above average\nhigh_gdp &lt;- aust[aust$gdpPercap &gt;= mean(aust$gdpPercap), ]\ndim(high_gdp)\n## [1] 5 6\n\n\n\n\n\n\n\nNote\n\n\n\nğŸ’¡ Understanding the â€œCommaâ€ Rule\nThe most common mistake for beginners is forgetting the comma inside the brackets: [rows, columns].\n\naust[aust$lifeExp &gt;= 70 ] â†’ Error! R doesnâ€™t know if this is a row or column instruction.\naust[aust$lifeExp &gt;= 70 , ] â†’ Success! The comma tells R: â€œFilter the rows based on this math, but keep all columns.â€",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "ğŸ­ğŸ­ Exploring Data Frames"
    ]
  },
  {
    "objectID": "WebsiteCodes/11AdvDataFrames.html#cleaning-your-data",
    "href": "WebsiteCodes/11AdvDataFrames.html#cleaning-your-data",
    "title": "Exploring Data Frames",
    "section": "3. Cleaning Your Data",
    "text": "3. Cleaning Your Data\nRaw datasets often contain â€œnoiseâ€â€”such as duplicate entries from technical replicates or empty rows created during data entry.\n\n3.1 Handling Duplicates\nDuplicates can artificially inflate your sample size and skew your statistics. The unique() function scans your data frame and keeps only the first instance of any identical rows.\n\naust &lt;- gapminder[gapminder$country == \"Australia\",]\n\n# Create a dataset with duplicates (binding the data to itself)\naust_double &lt;- rbind(aust, aust)\ndim(aust_double) # Should show 24 rows\n## [1] 24  6\n\n# Remove duplicate rows\naust_unique &lt;- unique(aust_double)\ndim(aust_unique) # Back to 12 rows!\n## [1] 12  6\n\n\n\n3.2 Handling Missing Values (NA)\nIn R, missing data is represented by NA (Not Available). Most statistical functions (like mean() or sd()) will fail or return NA if even one value is missing, so clearing them is essential.\n\nA. Identifying NAs: is.na()\nYou cannot use == NA to find missing data because NA is not a value; it is a placeholder. Instead, we use the logical function is.na().\n\n\nB. Filtering Out Empty Rows\nWe use the â€œLogical NOTâ€ operator (!) to tell R: â€œKeep only the rows where the column is NOT NA.â€\n\n# 1. Let's create an empty row for practice\n# rep(NA, ncol(aust)) creates a row of NAs the same width as our table\nna_row &lt;- rep(NA, ncol(aust))\naust &lt;- rbind(aust, na_row)\ntail(aust) # You will see the last row is all NA\n## # A tibble: 6 Ã— 6\n##   country   continent  year lifeExp      pop gdpPercap\n##   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n## 1 Australia Oceania    1987    76.3 16257249    21889.\n## 2 Australia Oceania    1992    77.6 17481977    23425.\n## 3 Australia Oceania    1997    78.8 18565243    26998.\n## 4 Australia Oceania    2002    80.4 19546792    30688.\n## 5 Australia Oceania    2007    81.2 20434176    34435.\n## 6 &lt;NA&gt;      &lt;NA&gt;         NA    NA         NA       NA\n\n# 2. Remove rows where 'country' is NA\n# We use !is.na() to keep the \"Not NA\" data\naust &lt;- aust[!is.na(aust$country), ]\n\ntail(aust) # The empty row is gone!\n## # A tibble: 6 Ã— 6\n##   country   continent  year lifeExp      pop gdpPercap\n##   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n## 1 Australia Oceania    1982    74.7 15184200    19477.\n## 2 Australia Oceania    1987    76.3 16257249    21889.\n## 3 Australia Oceania    1992    77.6 17481977    23425.\n## 4 Australia Oceania    1997    78.8 18565243    26998.\n## 5 Australia Oceania    2002    80.4 19546792    30688.\n## 6 Australia Oceania    2007    81.2 20434176    34435.\n\n\n\n\n\n\n\nNote\n\n\n\nRemove any row that has even one NA anywhere in it: na.omit\nIf you want to remove any row that has even one NA anywhere in it, you can use the â€œnuclear optionâ€:\n\naust_clean &lt;- na.omit(aust)\n\nWarning: Be careful with na.omit(). If a patient is missing just one minor piece of information (like a middle name), na.omit() will delete their entire record, including their vital clinical data! It is usually safer to filter by specific, essential columns using the !is.na() method.\n\n\n\n\n\n3.3 Editing Specific Elements\nIf you find a typo in your data, you can target a single â€œcellâ€ using [row, col].\n\n# Add 1 year to the Life Expectancy of the first row\naust[1, \"lifeExp\"] &lt;- aust[1, \"lifeExp\"] + 1\naust[1, ]\n## # A tibble: 1 Ã— 6\n##   country   continent  year lifeExp     pop gdpPercap\n##   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n## 1 Australia Oceania    1952    70.1 8691212    10040.\n\n# Specify the Life Expectancy of specific cell\naust[1, \"lifeExp\"] &lt;- 50\naust[1, ]\n## # A tibble: 1 Ã— 6\n##   country   continent  year lifeExp     pop gdpPercap\n##   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;\n## 1 Australia Oceania    1952      50 8691212    10040.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "ğŸ­ğŸ­ Exploring Data Frames"
    ]
  },
  {
    "objectID": "WebsiteCodes/09Packages.html#installing-new-packages",
    "href": "WebsiteCodes/09Packages.html#installing-new-packages",
    "title": "Installing New Packages",
    "section": "1. Installing New Packages",
    "text": "1. Installing New Packages\nThink of R as a smartphone. It comes with â€œfactory settingsâ€ (Base R), but to do specific things like high-quality plotting or RNA-seq analysis, you need to download â€œAppsâ€ (Packages).\n\n1.1 CRAN (The â€œApp Storeâ€)\nCRAN is the official repository for R. It is highly regulated and stable.\n\ninstall.packages(c(\"dplyr\", \"ggplot2\", \"gapminder\", \"medicaldata\"))\n\n\n\n\n\n\n\nNote\n\n\n\n\ndplyr: The â€œSwiss Army Knifeâ€ for data cleaning and table manipulation.\nggplot2: The gold standard for creating publication-quality figures (Nature/Science style).\ngapminder: A famous dataset about global life expectancy and GDP.\nmedicaldata: A collection of real-world clinical trial datasets.\n\n\n\n\n\n1.2 BioConductor (The Bioinformatics Specialized Store)\nBioConductor is specifically for biological data (Genomics, Proteomics, etc.). It has its own release cycle and installation manager.\n\n# 1. Install the Manager first\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\n# 2. Use the Manager to install tools like DESeq2\nBiocManager::install(\"DESeq2\")\n\n\n\n\n\n\n\nNote\n\n\n\nDESeq2: The standard tool for analyzing Differential Gene Expression from RNA-seq data.\n\n\n\n\n\n\n\n\nNoteWhat does that if sentence mean?\n\n\n\nThis is a â€œSmart Installationâ€ script. It checks if you already have the package before trying to download it again.\n\nrequire(\"BiocManager\"): This tries to load the package. If it succeeds, it returns TRUE. If the package is missing, it returns FALSE.\nThe ! (NOT) symbol: This flips the result.\n\nIf you HAVE the package (TRUE), it becomes FALSE â†’ The if block is skipped.\nIf you LACK the package (FALSE), it becomes TRUE â†’ The install.packages line runs.\n\nResult: It ensures your code doesnâ€™t waste 10 minutes re-installing a package you already have every time you run the script.\n\n\n\n\n\n1.3 GitHub (The Developerâ€™s Lab)\nIf a package is very new or in development, it might only be on GitHub. You need the devtools or remotes package to â€œcloneâ€ it.\n\n# devtools is not a default part of R; you must install it first\nif (!require(\"devtools\", quietly = TRUE))\n    install.packages(\"devtools\")\n\ndevtools::install_github(\"YuLab-SMU/ggmsa\")\n\n\n\n\n\n\n\nNote\n\n\n\nggmsa: A specialized tool for visualizing Multiple Sequence Alignments (MSAs) using ggplot2 logic.\n\n\n\n\n1.4 Choosing Your Source\n\nCRAN: Use for general data science (cleaning data, standard plots).\nBioConductor: Use for any â€œomicsâ€ data. This is where you find tools for Bulk/Single-cell RNA-seq.\nGitHub: Use only if the package isnâ€™t available elsewhere or if you need the absolute latest (but potentially â€œbuggyâ€) version.\n\n\n\n1.5 Finding the Right Tool\n\nBioconductor Views: A great place to browse by topic (e.g., â€œEpigeneticsâ€).\nRDocumentation.org: Search for any function name to see which package it belongs to.\nGoogle/Stack Overflow: Usually, if you search â€œHow to do X in R,â€ the top result will suggest a package.\n\n\n\n1.6 Important Notes on Installation\nWhen installing, R might ask: â€œDo you want to update other packages?â€\n\nRecommendation: Usually, choose â€œNoneâ€ or â€œNoâ€ if you are in a hurry, as updating everything can take a long time and occasionally break other code.\nThe â€œLibraryâ€ Step: Remember, install.packages() puts the app on your phone, but library() is what actually opens the app so you can use it.\n\n\n\n1.7 The â€œDouble Colonâ€ Trick\nNormally, we use library(package) to load all the tools from a package. However, you can access a specific function directly using the package::function() syntax.\n\nWhy use this?\n\nPreventing Naming Conflicts: Both the stats package (built into R) and the dplyr package have a function called filter(). If you load both, R will â€œmaskâ€ the older one. Using dplyr::filter() ensures R knows exactly which â€œfilterâ€ tool you want to use.\nClarity for Collaborators: When someone else reads your code, they might not know which package lfcShrink() belongs to. Writing DESeq2::lfcShrink() makes your code self-documenting.\nOne-Time Use: If you only need a package once in your entire script (like BiocManager::install()), it is cleaner to use the double colon than to load the entire library into your computerâ€™s memory.\n\n\n# Example 1: Installing without loading the manager\nBiocManager::install(\"DESeq2\")\n\n# Example 2: Being explicit about which 'filter' to use\n# This is very common in bioinformatics pipelines!\nclean_data &lt;- dplyr::filter(my_results, pvalue &lt; 0.05)\n\nThis is very common in bioinformatics scripts because it prevents â€œnaming conflictsâ€ (when two different packages have a function with the same name).\n\n\n\n1.8 Checking Package Versions\nIn bioinformatics, package versions change rapidly. A result you get with DESeq2 version 1.38 might be slightly different in version 1.42.\nTo ensure your research is reproducible, you should always check which version you are using before writing your paper.\n\n# Check the version of a specific package\npackageVersion(\"base\")\n\n# Or check everything currently loaded in your session\nsessionInfo()\n\n\n\n\n\n\n\nNote\n\n\n\nNote: The sessionInfo() command is a â€œbest practiceâ€ to run at the end of every analysis. It records your R version, your operating system, and every package version used.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Control Structures and Functions",
      "ğŸµ Installing New Packages"
    ]
  },
  {
    "objectID": "WebsiteCodes/07Loop.html#for-loop",
    "href": "WebsiteCodes/07Loop.html#for-loop",
    "title": "For & While Loops",
    "section": "1. For Loop",
    "text": "1. For Loop\nA For Loop is used when you know exactly how many times you want to repeat a task. You are â€œiteratingâ€ over a sequence (like a vector or a list).\nThe Logic (Pseudo-code):\n\n\n\n\n\n\nNote\n\n\n\nThink of a for loop like an assembly line. You have a box of items (a vector or list), and you pick them up one by one, do something to them, and set them aside until the box is empty.\n\n\n\nfor (EACH_ITEM in UR_COLLECTION) {\n    # 1. Take the current ITEM\n    # 2. Perform the ACTION (e.g., calculate its square root)\n    # 3. Move to the next ITEM automatically\n}\n\n# STOP: The loop ends automatically when the COLLECTION is empty\n\nExample: Counting\n\n# Iterate through the numbers 1 to 10\nfor (i in 1:10) {\n  print(i)\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n\n\nExample: Processing Strings\n\n# Iterate through a character vector\nx &lt;- c('a', 'ab', 'cab', 'taxi')\n\nfor (word in x) {\n  print(word)\n}\n\n[1] \"a\"\n[1] \"ab\"\n[1] \"cab\"\n[1] \"taxi\"\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe i or word in the code above is just a placeholder (an â€œiteratorâ€). You can name it anything you want, but using descriptive names like gene or sample makes your code much easier to read!",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Control Structures and Functions",
      "ğŸ³ For Loop/While Loop"
    ]
  },
  {
    "objectID": "WebsiteCodes/07Loop.html#while-loop",
    "href": "WebsiteCodes/07Loop.html#while-loop",
    "title": "For & While Loops",
    "section": "2. While Loop",
    "text": "2. While Loop\nA While Loop is more flexible but also more â€œdangerous.â€ It repeats a task as long as a certain condition remains TRUE.\nYou use this when you donâ€™t know exactly how many iterations you need, but you know when you want to stop.\nThe Logic (Pseudo-code):\n\n\n\n\n\n\nNote\n\n\n\nThink of a while loop like a security guard at a gate. The guard checks the condition before letting the code inside. If the condition is still true, the code runs, and then it goes back to the guard to check again.\n\n\n\nWHILE (condition is TRUE) {\n    1. Perform the ACTION (e.g., print a value or do math)\n    2. UPDATE the variables involved in the condition \n       (If you don't update them, the loop runs forever!)\n}\n# STOP: The loop ends automatically when the condition becomes FALSE\n\nExample:\n\nx &lt;- 5\n\n# While x is greater than 0, keep running\nwhile (x &gt; 0) {\n  print(x)\n  # Crucial: you must change x, or the loop will run forever!\n  x &lt;- x - 1\n}\n\n[1] 5\n[1] 4\n[1] 3\n[1] 2\n[1] 1\n\n\n\n\n\n\n\n\nCautionA Cautionary Note on While Loops\n\n\n\nIf your condition in a while loop never becomes FALSE (for example, if you forgot to write x &lt;- x - 1), you create an Infinite Loop.\nThis will cause R to hang or crash. If this happens, look for the red â€œStopâ€ icon in the top-right of your RStudio Console to break the loop!",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Control Structures and Functions",
      "ğŸ³ For Loop/While Loop"
    ]
  },
  {
    "objectID": "WebsiteCodes/07Loop.html#comparison-of-iteration-methods",
    "href": "WebsiteCodes/07Loop.html#comparison-of-iteration-methods",
    "title": "For & While Loops",
    "section": "3. Comparison of Iteration Methods",
    "text": "3. Comparison of Iteration Methods\nIn R, we often prefer Vectorized functions (the â€œApplyâ€ family) over for loops because they are usually faster and require less code.\n\n\n\n\n\n\n\n\nMethod\nBest Use Case\nOutput Type\n\n\nfor loop\nComplex logic with many steps.\nWhatever you define.\n\n\nwhile loop\nSimulations or tasks with unknown end-points.\nWhatever you define.\n\n\nlapply\nApplying a function to every element of a list/vector.\nList\n\n\nsapply\nSame as lapply, but tries to â€œsimplifyâ€ the result.\nVector or Matrix",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Control Structures and Functions",
      "ğŸ³ For Loop/While Loop"
    ]
  },
  {
    "objectID": "WebsiteCodes/07Loop.html#the-apply-family-lapply-and-sapply",
    "href": "WebsiteCodes/07Loop.html#the-apply-family-lapply-and-sapply",
    "title": "For & While Loops",
    "section": "4. The â€œApplyâ€ Family (lapply and sapply)",
    "text": "4. The â€œApplyâ€ Family (lapply and sapply)\nIn modern R, lapply (List Apply) and sapply (Simple Apply) are the gold standard for iteration. They are cleaner and less prone to â€œoff-by-oneâ€ errors than standard loops.\n\n4.1 lapply\nAlways returns a list. This is great for bioinformatics because it can store complex results (like model outputs) for each gene.\n\ngenes &lt;- c(\"BRCA1\", \"TP53\", \"EGFR\")\n\n# Convert every gene name to lowercase\nresults_list &lt;- lapply(genes, tolower)\nresults_list\n\n[[1]]\n[1] \"brca1\"\n\n[[2]]\n[1] \"tp53\"\n\n[[3]]\n[1] \"egfr\"\n\n\n\n\n4.2 sapply\nDoes the same thing as lapply, but it tries to â€œsimplifyâ€ the result into a vector if possible.\n\n# Convert every gene name to lowercase and return a vector\nresults_vector &lt;- sapply(genes, tolower)\nresults_vector\n\n  BRCA1    TP53    EGFR \n\"brca1\"  \"tp53\"  \"egfr\"",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Control Structures and Functions",
      "ğŸ³ For Loop/While Loop"
    ]
  },
  {
    "objectID": "WebsiteCodes/07Loop.html#complicated-case-sapply-with-a-custom-function",
    "href": "WebsiteCodes/07Loop.html#complicated-case-sapply-with-a-custom-function",
    "title": "For & While Loops",
    "section": "5. Complicated Case: sapply with a Custom Function",
    "text": "5. Complicated Case: sapply with a Custom Function\nIn bioinformatics, we often need to do more than just simple math. We might want to â€œScoreâ€ a list of genes based on several criteria at once.\nIn this case, we will write a Custom Function and then use sapply to â€œflyâ€ that function over a vector of gene expression values.\n\nThe Scenario:\nWe have a vector of Gene Expression values. We want to label them:\n\nâ€œHighâ€ if the value is &gt;100.\nâ€œLowâ€ if the value is &lt;10.\nâ€œMediumâ€ for everything else.\n\n\n# 1. Create our data (Sample Gene Expression)\nexpression_values &lt;- c(150, 5, 45, 200, 8, 55)\nnames(expression_values) &lt;- c(\"Gene_A\", \"Gene_B\", \"Gene_C\", \"Gene_D\", \"Gene_E\", \"Gene_F\")\n\n# 2. Write a Custom Function to handle the logic\n# This function takes ONE number and returns ONE label\nclassify_gene &lt;- function(x) {\n  if (x &gt; 100) {\n    return(\"High\")\n  } else if (x &lt; 10) {\n    return(\"Low\")\n  } else {\n    return(\"Medium\")\n  }\n}\n\n# 3. Use sapply to apply this function to every value in our vector\n# sapply handles the \"looping\" for us!\ngene_status &lt;- sapply(expression_values, classify_gene)\n\n# 4. Look at the result\ngene_status\n\n  Gene_A   Gene_B   Gene_C   Gene_D   Gene_E   Gene_F \n  \"High\"    \"Low\" \"Medium\"   \"High\"    \"Low\" \"Medium\"",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Control Structures and Functions",
      "ğŸ³ For Loop/While Loop"
    ]
  },
  {
    "objectID": "WebsiteCodes/05Objects.html",
    "href": "WebsiteCodes/05Objects.html",
    "title": "Objects (Data Structures)",
    "section": "",
    "text": "In R, Data Structures are the containers used to store and organize values.\nR provides several built-in structures, each designed for a specific purpose. Understanding the difference between them is critical for data analysis.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ± Objects (Data Structures)"
    ]
  },
  {
    "objectID": "WebsiteCodes/05Objects.html#overview-of-data-dimension",
    "href": "WebsiteCodes/05Objects.html#overview-of-data-dimension",
    "title": "Objects (Data Structures)",
    "section": "1. Overview of Data Dimension",
    "text": "1. Overview of Data Dimension\n\n\n\n1D Structures\n(Vector, Factor, List) \n\n\n\n\n\n2D Structures\n(Matrix, Data Frame)",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ± Objects (Data Structures)"
    ]
  },
  {
    "objectID": "WebsiteCodes/05Objects.html#vector",
    "href": "WebsiteCodes/05Objects.html#vector",
    "title": "Objects (Data Structures)",
    "section": "2. Vector",
    "text": "2. Vector\nKey points:\n\nThe fundamental building block of R.\nThe Vector is a 1D sequence.\nCan only contain objects of the same class (e.g., all numeric or all character).\nEven a single number in R is actually a vector of length 1.\n\nExample of vector: Numeric/integer Vectors, Logical Vectors, Character Vectors.\n\n\n\n\n\n\n2.1 Numeric Vectors\nThere are multiple ways to create numeric vectors.\n\n2.1.1 Method A: c() (Combine)\nThis is the most common method.\n\nx &lt;- c(0.3, 0.1)\nx\n\n[1] 0.3 0.1\n\nis.vector(x)\n\n[1] TRUE\n\n\n\n\n\n\n\n\nNote\n\n\n\nc() Function\nHow should we understand c()?\n\nThe Abbreviation: c stands for Combine (or sometimes Concatenate).\nThe Concept: You can think of c() as a â€œGlueâ€ or a â€œContainer.â€ It takes individual, separate values and glues them together into a single, ordered sequence.\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nCoding Style:\nThe Comma Rule It is not mandatory to put a space after a commaâ€”both c(0.3, 0.1) and c(0.3,0.1) will work perfectly.\nHowever, much like writing in English, your code is significantly easier for others (and your future self) to read if you consistently place a space after every comma. It makes your code look professional and clean.\n\n\n\n\n2.1.2 Method B: vector() or numeric()\nCreates an empty vector of a specific size (defaults to 0).\n\nx &lt;- vector(mode = \"numeric\", length = 10)\nx\n\n [1] 0 0 0 0 0 0 0 0 0 0\n\n\n\nx &lt;- numeric(length = 10)\nx\n\n [1] 0 0 0 0 0 0 0 0 0 0\n\n\n\n\n2.1.3 Method C: seq() and rep()\nSequences (seq and rep) are useful for generating data automatically.\n\n# Sequence from 1 to 10, jumping by 2\nx &lt;- seq(from = 1, to = 10, by = 2)\nx\n## [1] 1 3 5 7 9\nis.vector(x)\n## [1] TRUE\n\n# Repeat the number 2, 10 times\nx &lt;- rep(2, 10)\nx\n##  [1] 2 2 2 2 2 2 2 2 2 2\nis.vector(x)\n## [1] TRUE\n\n\n\n\n\n\n\nTip\n\n\n\nChecking Vector Length with length()\n\n## Creates an empty vector of length 10\nx &lt;- vector(mode = \"numeric\", length = 10)\nx\n##  [1] 0 0 0 0 0 0 0 0 0 0\nlength(x)\n## [1] 10\n\n# Repeat the number 2, 5 times\ny &lt;- rep(2, 5)\ny\n## [1] 2 2 2 2 2\nlength(y)\n## [1] 5\n\nlength(x) == length(y)\n## [1] FALSE\n\n\n\n\n\n\n2.2 Integer Vectors\nIntegers are whole numbers. You force them by adding L.\nCreating an integer vector using c()\n\nx &lt;- c(1L, 2L, 3L, 4L, 5L)  \nx\n\n[1] 1 2 3 4 5\n\n\nThe Colon Operator (:) The quickest way to make an integer sequence.\n\nx &lt;- 1:10\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n\n\n\n\n\nNote\n\n\n\nNotes:\nYou can read the : symbol as â€œfromâ€¦ toâ€¦â€\n\n1:10 means â€œfrom 1 to 10.â€\n50:100 means â€œfrom 50 to 100.â€\n\n\n\n\n\n2.3 Logical Vectors\nUsed for True/False conditions.\n\n# You can use TRUE/FALSE or T/F\nx &lt;- c(TRUE, FALSE, T, F)\nx\n\n[1]  TRUE FALSE  TRUE FALSE\n\n\nCreating a logical vector with vector()\n\nx &lt;- vector(mode = \"logical\", length = 5)\nx\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\n\nCreating a logical vector using logical()\n\nx &lt;- logical(length = 10)\nx\n\n [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n\n\n2.4 Character Vectors\nText strings must be wrapped in quotes.\n\nx &lt;- c(\"a\", \"b\", \"c\")\nx\n## [1] \"a\" \"b\" \"c\"\n\n# Creates an empty character vector of a specific size (defaults to blank).\nx &lt;- vector(mode = \"character\", length=10)\nx\n##  [1] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\"\n\nx &lt;- character(length = 3)\nx\n## [1] \"\" \"\" \"\"\n\n\n\n\n\n\n\nTip\n\n\n\nUseful String Functions\n\n# Convert to Lowercase\ntolower(c(\"DNA\", \"RNA\"))\n## [1] \"dna\" \"rna\"\n\n# Convert to UPERCASE\ntoupper(letters)\n##  [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n## [20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n\n# Create labels by pasting text and numbers\n# Note the implicit coercion\npaste(\"Patient\", 1:5, sep = \"_\")\n## [1] \"Patient_1\" \"Patient_2\" \"Patient_3\" \"Patient_4\" \"Patient_5\"\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn R, coercion is the process of forced conversion from one data type to another.\nR is automatically changing the Numeric vector (1:5) into a Character vector so it can be â€œpastedâ€ together with the Character vector (â€œPatientâ€).\n\nThe Rule of Vectors\nAs we learned earlier, a vector must contain objects of the same class. You cannot have a single vector that is half-numbers and half-text.\nWhat happens in paste()?\nWhen you run paste(\"Patient\", 1:5, sep = \"_\"):\n\nâ€œPatientâ€ is a Character vector.\n1:5 is an Integer/Numeric vector (1, 2, 3â€¦).\nSince you canâ€™t join â€œtextâ€ and â€œnumbersâ€ into a single result without them being the same type, R implicitly (automatically) converts the numbers into text strings (â€œ1â€, â€œ2â€, â€œ3â€).\n\nWhy is this important?\n\nIn R, there is a â€œHierarchy of Types.â€ If you mix different types in a vector, R will always coerce them to the â€œleast restrictiveâ€ type to ensure no data is lost, following this order:\nLogical â†’ Integer â†’ Numeric â†’ Character\n\nExample of unexpected coercion:\n\nIf you accidentally include a single piece of text in your column of gene expression numbers, R will turn the entire column into text.\n\n\n# Mixing numbers and one \"missing\" string\ndata &lt;- c(1.2, 3.5, \"missing\", 4.8)\n\n# Check the class\nclass(data)\n## [1] \"character\"\nis.numeric(data)\n## [1] FALSE\n\n\nBecause of coercion, you can no longer calculate the mean() or sum() of that data because R now sees them all as â€œcharacterâ€ rather than â€œnumbers.â€ This is a very common reason why R scripts fail during data cleaning!\n\n\n   # Mixing numbers and one \"missing\" string\ndata &lt;- c(1.2, 3.5, \"missing\", 4.8)\n\nmean(data)\n\nWarning in mean.default(data): argument is not numeric or logical: returning NA\n\n\n[1] NA\n\n\n\n\n\n\n\n2.5 Vector Attributes (Names)\nYou can give names to specific elements in a vector. This is great for readability.\n\nx &lt;- 1:5\nnames(x) &lt;- c(\"one\", \"two\", \"three\", \"four\", \"five\")\nx\n\n  one   two three  four  five \n    1     2     3     4     5 \n\nx &lt;- logical(length = 4)\nnames(x) &lt;- c(\"F1\", \"F2\", \"F3\", \"F4\")\nx\n\n   F1    F2    F3    F4 \nFALSE FALSE FALSE FALSE \n\n\n\n\n2.6 Vector indexing\nIn R, indices are 1-based, meaning the first item is at position 1. For these examples, we will use a vector of 15 random numbers.\n\n# We set a seed so everyone in the workshop gets the same 15 numbers\nset.seed(228)\n\n# Create 15 unique random numbers between 1 and 100\nx &lt;- sample(x = 1:100, size = 15, replace = FALSE)\nx\n\n [1] 84 61 52 40 62 88 49 65 28 18 75 46 83 23 16\n\n\n\n\n\n\n\n\nTip\n\n\n\nReproducible Randomness: set.seed()\nThe sample() function generates random numbers. Ordinarily, every time you run it, you get a different result. However, in scientific research, we need our results to be reproducible.\nThe set.seed() function provides a â€œsecret keyâ€ (the seed) to the random number generator. As long as two people use the same seed, they will get the exact same â€œrandomâ€ numbers every time. The seed can be any number you likeâ€”important date, your favorite number, or even a random string of digits.\nFun facts: the number 42 is one of the most popular seeds in the world, appearing in roughly 4% of all public code. This is a nod to Douglas Adamsâ€™ The Hitchhikerâ€™s Guide to the Galaxy, where 42 is the â€œAnswer to the Ultimate Question of Life, the Universe, and Everything.â€\n\n\n\n2.6.1 Using Position (Numeric Indexing)\nYou can grab a single item or a range of items using square brackets [].\n\nx[1]   # Get the first element\n## [1] 84\nx[13]  # Get the thirteenth element\n## [1] 83\n\n# Get the first 12 numbers using a sequence\nx[1:12] \n##  [1] 84 61 52 40 62 88 49 65 28 18 75 46\n\n# Get specific positions using a vector of indices\nx[c(1, 5, 9)]\n## [1] 84 62 28\n\n\n\n2.6.2 Using Names\nIf your vector has names assigned to its elements, you can use those names (as strings) to pull data. This is much safer than numeric indexing because the name stays with the data even if the order changes.\n\n# Assign letters a-o as names to our 15 numbers\nnames(x) &lt;- letters[1:length(x)]\n\n# Access specific elements by name\nx[c(\"a\", \"c\", \"d\")]\n\n a  c  d \n84 52 40 \n\n\n\n\n2.6.3 Using Logical Filters (The â€œQuestionâ€ Method)\nThis is the most powerful way to index. Instead of giving a position, you give R a Logical Vector (TRUE/FALSE). R will only return the items that are TRUE.\n\n# Which numbers are greater than 50?\nx[x &gt; 50] \n##  a  b  c  e  f  h  k  m \n## 84 61 52 62 88 65 75 83\n\n# Only return numbers that are less than or equal to 30\nx[x &lt;= 30]\n##  i  j  n  o \n## 28 18 23 16\n\n# Only return even numbers (using the Modulus operator %%)\nx[x %% 2 == 0]\n##  a  c  d  e  f  i  j  l  o \n## 84 52 40 62 88 28 18 46 16\n\n\n\n2.6.4 Skipping Elements\nSometimes you want everything except a few specific items. In R, you do this by using a negative sign - or the Not Equal != operator.\nUsing Negative Indices:\n\n# Return the vector EXCEPT the 1st and 5th elements\nx[c(-1, -5)]\n\n b  c  d  f  g  h  i  j  k  l  m  n  o \n61 52 40 88 49 65 28 18 75 46 83 23 16 \n\n\nUsing Names:\n\n# Return everything EXCEPT the element named \"a\"\nx[names(x) != \"a\"]\n\n b  c  d  e  f  g  h  i  j  k  l  m  n  o \n61 52 40 62 88 49 65 28 18 75 46 83 23 16",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ± Objects (Data Structures)"
    ]
  },
  {
    "objectID": "WebsiteCodes/05Objects.html#factors",
    "href": "WebsiteCodes/05Objects.html#factors",
    "title": "Objects (Data Structures)",
    "section": "3. Factors",
    "text": "3. Factors\nThink of a Factor as a â€œSmart Character.â€ Itâ€™s a way to tell R: â€œThese words arenâ€™t just text; they are specific categories.â€\nKey points:\n\nUsed for Categorical Data (e.g., â€œControlâ€ vs â€œTreatmentâ€).\nLevels: The fixed set of possible values.\nCan have implicit order, if needed.\n\nUnlike simple text, factors can be ordered.\nThis is vital for data like cancer stages (Stage I &lt; Stage II &lt; Stage III) or dose levels (Low &lt; Med &lt; High).\n\nEach element has a label or level\nEssential for statistical modeling (e.g., defining groups for DESeq2).\nSome operations behave differently on factors\n\n\n\n\n\n\nCreating Factors: Notice below that we explicitly define the levels. This sets the â€œorderâ€ of the groups (Control first, Case second).\n\ncols &lt;- factor(x = c(rep(\"red\", 4),\n                   rep(\"blue\", 5),\n                   rep(\"green\", 2)),              \n             levels = c(\"red\", \"blue\", \"green\"))\ncols\n\n [1] red   red   red   red   blue  blue  blue  blue  blue  green green\nLevels: red blue green\n\n\n\nsamples &lt;- c(\"case\", \"control\", \"control\", \"case\") \nsamples_factor &lt;- factor(samples, levels = c(\"control\", \"case\")) \n\nsamples_factor \n\n[1] case    control control case   \nLevels: control case\n\nis.factor(samples_factor)\n\n[1] TRUE\n\nstr(samples_factor)\n\n Factor w/ 2 levels \"control\",\"case\": 2 1 1 2",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ± Objects (Data Structures)"
    ]
  },
  {
    "objectID": "WebsiteCodes/05Objects.html#list",
    "href": "WebsiteCodes/05Objects.html#list",
    "title": "Objects (Data Structures)",
    "section": "4. List",
    "text": "4. List\nLists are the most flexible data structure in R. They are 1D containers that can hold anything: numbers, text, or even other lists,.\nKey points:\n\nThe â€œSuper Containerâ€.\nCan contain mixed data types (e.g., a vector, a matrix, and a string all in one object).\nThe output of most statistical tests (like t.test) is a list.\n\n\n\n\n\n\n\n4.1 Creating and Naming Lists\nYou can create a list with various data types and assign names to the â€œpocketsâ€ of your backpack for easy access.\n\nmy_list &lt;- list(\n  project_name = \"Diabetes Study\",\n  patient_count = 50,\n  is_finished = FALSE,\n  group_ids = c(\"A\", \"B\", \"C\")\n)\n\nmy_list\n\n$project_name\n[1] \"Diabetes Study\"\n\n$patient_count\n[1] 50\n\n$is_finished\n[1] FALSE\n\n$group_ids\n[1] \"A\" \"B\" \"C\"\n\nnames(my_list)\n\n[1] \"project_name\"  \"patient_count\" \"is_finished\"   \"group_ids\"    \n\n\n\n\n4.2 Indexing and subsetting\nAccessing List Elements:\nUse the double bracket [[ ]] or the dollar sign $ for named lists.\n\nmy_list[[\"group_ids\"]]\n\n[1] \"A\" \"B\" \"C\"\n\nmy_list$project_name\n\n[1] \"Diabetes Study\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nOne of the most confusing parts of R for beginners is the difference between [] and [[]]. Think of a list as a train carrying cargo:\n\nl[1] (Single Bracket): This returns the train car itself. The result is still a list.\nl[[1]] (Double Bracket): This â€œunzipsâ€ the car and returns the actual cargo inside.\n\nFor example:\n\nmy_list[4]\n## $group_ids\n## [1] \"A\" \"B\" \"C\"\n\nmy_list[[4]]\n## [1] \"A\" \"B\" \"C\"\n\n\n\n\n\n4.3 Automated Operations with lapply\nIn bioinformatics, we often have lists of data (e.g., a list of three different gene sets). If you want to perform the same math on every set, you use lapply() (the â€œList Applyâ€ function).\n\n# Create a list of 3 random sample sets\nl &lt;- list(\n  r1 = sample(1:100, 10), \n  r2 = sample(1:100, 10), \n  r3 = sample(1:100, 10)\n)\n\n# Apply the sum function to EVERY element in the list\nlsums &lt;- lapply(l, sum)\nlsums\n\n$r1\n[1] 557\n\n$r2\n[1] 765\n\n$r3\n[1] 632\n\n\n\n\n\n\n\n\nNote\n\n\n\nlapply always returns a List. If you want a simple vector instead, you can use sapply (the â€œSimplified Applyâ€), which is like lapply but tries to tidy the result into a vector for you.\nFor example:\n\nssums &lt;- sapply(l, sum)\nssums\n\n r1  r2  r3 \n557 765 632",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ± Objects (Data Structures)"
    ]
  },
  {
    "objectID": "WebsiteCodes/05Objects.html#matrix",
    "href": "WebsiteCodes/05Objects.html#matrix",
    "title": "Objects (Data Structures)",
    "section": "5. Matrix",
    "text": "5. Matrix\nKey points:\n\n2-Dimensional (Rows and Columns).\nMust contain One Data Type (usually all Numeric).\nUsed heavily in bioinformatics for Gene Expression Tables (Genes Ã— Samples).\n\n\n\n\n\n\nCreating a Matrix:\n\n# Create a matrix of numbers 1 through 9, arranged in 3 rows\nm &lt;- matrix(1:9, nrow = 3, ncol = 3)\nm\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n\nAdding Row/Column Names:\n\nm &lt;- matrix(1:9, nrow = 3, ncol = 3)\ncolnames(m) &lt;- c(\"Sample1\", \"Sample2\", \"Sample3\")\nrownames(m) &lt;- c(\"GeneA\", \"GeneB\", \"GeneC\")\nm\n\n      Sample1 Sample2 Sample3\nGeneA       1       4       7\nGeneB       2       5       8\nGeneC       3       6       9\n\n\n\n5.1 Confirming Matrix Structure and Size\nWhen working with matricesâ€”such as a gene expression matrixâ€”it is essential to verify that the dimensions (rows and columns) match your expectations.\nIn the example below, we create a matrix with 10 elements.\n\n# Create a matrix with 10 numbers, arranged in 5 rows and 2 columns\nm &lt;- matrix(1:10, nrow = 5, ncol = 2)\n\nm\n\n     [,1] [,2]\n[1,]    1    6\n[2,]    2    7\n[3,]    3    8\n[4,]    4    9\n[5,]    5   10\n\n\n\nChecking the Object Type\nThese functions tell you what the object is.\n\n\n\n\n\n\nNote\n\n\n\n\nclass(): Returns the abstract type of the object (e.g., \"matrix\", \"array\").\ntypeof(): Returns the internal â€œstorageâ€ mode of the data (e.g., \"integer\", \"double\").\n\n\n\n\n# Create a matrix with 10 numbers, arranged in 5 rows and 2 columns\nm &lt;- matrix(1:10, nrow = 5, ncol = 2)\n\nclass(m)\n## [1] \"matrix\" \"array\"\ntypeof(m)\n## [1] \"integer\"\n\n\n\n\n\n\n\nNoteWhy does class() show both â€œmatrixâ€ and â€œarrayâ€?\n\n\n\nIn R, a matrix is technically just a special case of an array.\nThink of it like this:\n\nAn Array is the â€œGrandparentâ€ (it can have 1, 2, 3, or 100 dimensions).\nA Matrix is the â€œParentâ€ (it is an array that is strictly 2-dimensional).\n\nWhen you ask for the class, R is telling you: â€œThis object is a matrix, which means it also inherits all the properties of an array.â€\n\n\n\n\n\n\n\n\nNoteWhy is typeof(m) â€œintegerâ€ instead of â€œnumericâ€?\n\n\n\nThis is because of the Colon Operator (:) you used to create the data.\nIn R, the : operator specifically creates Integers (whole numbers) because they take up less memory than â€œDoublesâ€ (numbers with decimals).\n\nInteger: Whole numbers (1L, 2L, 3L).\nNumeric (Double): Numbers that can have decimals (1.0, 2.5, 3.14).\n\nBecause your matrix m was built using 1:10, R stored them as integers to be efficient.\n\n\n\n\nInspecting Dimensions and Size\nThese functions tell you how big the object is.\n\n\n\n\n\n\nNote\n\n\n\n\ndim(): Returns both the number of rows and columns as a vector.\nnrow(): Returns only the number of rows (e.g., the number of Genes).\nncol(): Returns only the number of columns (e.g., the number of Samples).\n\n\n\n\nm &lt;- matrix(1:10, nrow = 5, ncol = 2)\n\ndim(m)\n## [1] 5 2\nnrow(m)\n## [1] 5\nncol(m)\n## [1] 2\n\n\n\nThe â€œEverythingâ€ Function: str()\nThe str() (structure) function is perhaps the most useful tool for a researcher. It provides a compact summary of the class, the dimensions, the data type, and a preview of the first few values all in one line.\n\nm &lt;- matrix(1:10, nrow = 5, ncol = 2)\nstr(m)\n\n int [1:5, 1:2] 1 2 3 4 5 6 7 8 9 10",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ± Objects (Data Structures)"
    ]
  },
  {
    "objectID": "WebsiteCodes/05Objects.html#array",
    "href": "WebsiteCodes/05Objects.html#array",
    "title": "Objects (Data Structures)",
    "section": "6. Array",
    "text": "6. Array\nKey points:\n\nSimilar to a matrix, but can have more than 2 dimensions (3D, 4D, etc.).\nUseful for time-series data or 3D imaging data.\n\n\n# Create a 3D array (2 rows, 2 columns, 2 \"slices\")\na &lt;- array(1:8, dim = c(2, 2, 2))\na\n\n, , 1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n, , 2\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ± Objects (Data Structures)"
    ]
  },
  {
    "objectID": "WebsiteCodes/05Objects.html#data-frame",
    "href": "WebsiteCodes/05Objects.html#data-frame",
    "title": "Objects (Data Structures)",
    "section": "7. Data Frame",
    "text": "7. Data Frame\nKey points:\n\nThe most common data structure for researchers.\n2-Dimensional (like a matrix).\nCan mix data types (e.g., Column 1 is Numeric, Column 2 is Character).\n\nColumns in data frames are vectors\nA data frame is essentially a list of vectors\n\nThink of it like an Excel Spreadsheet.\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe Three Rules of Data Frame Anatomy\n1. The Column Rule (The Vector)\nEvery column in a data frame is a Vector.\nThis means that within a single column (like Age or Gene_Expression), every single entry must be the same data type. You cannot have a number in row 1 and a word in row 2 of the same column.\n2. The Row Rule (The List)\nThe data frame itself is a List where each element of the list is one of those columns.\nBecause a list can hold different types of objects, your first list element (Column 1) can be â€œNumericâ€ and your second list element (Column 2) can be â€œCharacter.â€\n3. The Alignment Rule (The â€œRectangleâ€)\nThis is the only way a Data Frame differs from a standard List:\n\nIn a List, you can have one vector of length 10 and another vector of length 500.\nIn a Data Frame, R forces a â€œRectangularâ€ constraint. Every column (vector) must have the exact same length.\n\n\n\nCreating a Data Frame:\n\ndf &lt;- data.frame(\n  ID = c(\"P001\", \"P002\", \"P003\"),\n  Age = c(25, 34, 28),\n  Treatment = c(\"Placebo\", \"Drug\", \"Placebo\")\n)\ndf\n\n    ID Age Treatment\n1 P001  25   Placebo\n2 P002  34      Drug\n3 P003  28   Placebo\n\n\n\n7.1 Confirming Data Frame Structure and Size\n\ndf &lt;- data.frame(\n  ID = c(\"P001\", \"P002\", \"P003\"),\n  Age = c(25, 34, 28),\n  Treatment = c(\"Placebo\", \"Drug\", \"Placebo\")\n)\n\nclass(df)\n## [1] \"data.frame\"\ntypeof(df)\n## [1] \"list\"\ndim(df)\n## [1] 3 3\nstr(df)\n## 'data.frame':    3 obs. of  3 variables:\n##  $ ID       : chr  \"P001\" \"P002\" \"P003\"\n##  $ Age      : num  25 34 28\n##  $ Treatment: chr  \"Placebo\" \"Drug\" \"Placebo\"\nhead(df)\n##     ID Age Treatment\n## 1 P001  25   Placebo\n## 2 P002  34      Drug\n## 3 P003  28   Placebo\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\n\n\n\n\n\nFunction\nWhat it tells you\nWhy it matters\n\n\nclass()\nThe high-level structure.\nConfirms you have a data.frame and not just a simple list or matrix.\n\n\ntypeof()\nThe internal Storage Type.\nReveals how R stores the data in your computerâ€™s memory. For a data frame, this will return \"list\", because a data frame is technically a list of equal-length vectors.\n\n\ndim()\nThe Dimensions (Rows, then Columns).\nCrucial. Tells you how many samples (rows) and variables (cols) you have.\n\n\nstr()\nThe internal structure.\nShows the data type of every column at once (e.g., is Age numeric or text?).\n\n\nhead()\nThe first 6 rows.\nA â€œsanity checkâ€ to see if the data looks like you expected.\n\n\ntail()\nThe last 6 rows.\nUseful for checking if the file ended correctly or has â€œjunkâ€ at the bottom.\n\n\n\n\n\n\n\n7.2 Re-naming columns\nYou can rename a specific column by targeting its index (its position number).\n\n# Let's rename the 3nd column to \"Group\"\ndf &lt;- data.frame(\n  ID = c(\"P001\", \"P002\", \"P003\"),\n  Age = c(25, 34, 28),\n  Treatment = c(\"Placebo\", \"Drug\", \"Placebo\")\n)\n\ncolnames(df)[3] &lt;- \"Group\"\n\n# Check the change\nhead(df)\n\n    ID Age   Group\n1 P001  25 Placebo\n2 P002  34    Drug\n3 P003  28 Placebo\n\n\n\n\n7.3 Indexing and sub-setting\nThere are three main ways to pull data out of a data frame. Think of this as giving R an â€œaddressâ€ to find your data.\n\nMethod A: The Dollar Sign ($)\nThe most common way to grab a single column by its name. This returns a vector.\n\ndf$ID\n\n[1] \"P001\" \"P002\" \"P003\"\n\n\n\n\nMethod B: Single Brackets with Name ([ ])\nThis returns a data frame containing only that column.\n\ndf[\"Age\"]\n\n  Age\n1  25\n2  34\n3  28\n\n\n\n\nMethod C: Coordinate Indexing ([row, col])\nThis is the most precise method. You provide the Row number, then a comma, then the Column number.\n\ndf[1, ]: The 1st Row (all columns).\ndf[, 1]: The 1st Column (all rows).\ndf[3, 2]: The specific value at Row 3, Column 2.\n\n\ndf[,3]\n\n[1] \"Placebo\" \"Drug\"    \"Placebo\"\n\n\n\n\nMethod D: Logical Sub-setting with which()\nThis is how you â€œfilterâ€ your data based on conditions. The which() function tells R the index numbers that meet your criteria.\n\ndf[which(df$ID %in% c(\"P002\", \"P003\")), ]\n\n    ID Age   Group\n2 P002  34    Drug\n3 P003  28 Placebo\n\n\n\n\n\n\n\n\nNote\n\n\n\nHow to read the â€œSubsetting Sandwichâ€\nThink of the line df[which(df$ID %in% c(\"P002\", \"P003\")), ] as a three-layer process. R evaluates this from the inside out.\nLayer 1: The Question (%in%)\n\ndf$ID %in% c(\"P002\", \"P003\") R looks at the ID column and asks: â€œIs the value in this row either P002 or P003?â€\nThe Result: A Logical Vector like [FALSE, TRUE, TRUE, FALSE, ...].\n\nLayer 2: The Address Finder (which)\n\nwhich(...) R takes those TRUE/FALSE values and converts them into index numbers (row numbers). If the 2nd and 3rd rows were TRUE, which() returns the numbers 2 and 3.\nThe Result: An Integer Vector like [2, 3].\n\nLayer 3: The Grabber ([row, col])\n\ndf[2:3, ] Finally, R uses those numbers as the Row Address.\nThe comma is the most important part! By leaving the space after the comma blank, you are telling R: â€œGive me all columns for these specific rows.â€\n\n\nWhy does the Comma do?\n\ndf[rows , ] â†’ â€œI want these rows, and keep all the columns.â€\ndf[ , cols] â†’ â€œI want all the rows, but only these columns.â€\n\n\n\n\n\n\n7.4 Coercion\nCoercion is the act of forcing an object to change from one structure or type to another. We use the as. family of functions to do this.\n\nList to Data Frame\nThis is a very common workflow: you collect various results in a list and then â€œsolidifyâ€ them into a rectangular data frame for plotting or saving.\n\n# 1. Create a list with two vectors of equal length\nl &lt;- list(numbers = 1:10, lowercase = letters[1:10])\n\n# 2. Check type\ntypeof(l)\n## [1] \"list\"\n\n# 3. Coerce the list into a data frame\ndf &lt;- as.data.frame(l)\n\n# 4. Observe the change\ntypeof(df)\n## [1] \"list\"\nhead(df)\n##   numbers lowercase\n## 1       1         a\n## 2       2         b\n## 3       3         c\n## 4       4         d\n## 5       5         e\n## 6       6         f",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ± Objects (Data Structures)"
    ]
  },
  {
    "objectID": "WebsiteCodes/05Objects.html#null-the-empty-object",
    "href": "WebsiteCodes/05Objects.html#null-the-empty-object",
    "title": "Objects (Data Structures)",
    "section": "8. NULL (The Empty Object)",
    "text": "8. NULL (The Empty Object)\nKey points:\n\nNULL represents the absence of an object.\nIt is different from NA (which means â€œmissing valueâ€).\nNULL is often used to remove an element from a list or dataframe.\n\n\nx &lt;- NULL\nis.null(x)\n\n[1] TRUE",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ± Objects (Data Structures)"
    ]
  },
  {
    "objectID": "WebsiteCodes/05Objects.html#built-in-functions",
    "href": "WebsiteCodes/05Objects.html#built-in-functions",
    "title": "Objects (Data Structures)",
    "section": "9. Built-in Functions",
    "text": "9. Built-in Functions\nR has many functions to inspect and summarize these objects.\n\n9.1 Inspection Functions\nUse these to check what you are working with.\n\nx &lt;- c(1, 2, 3)\n\nis.vector(x)    # Is it a vector?\n## [1] TRUE\nis.na(x)    # Is it empty\n## [1] FALSE FALSE FALSE\nis.null(x)    # Is it NULL\n## [1] FALSE\nis.numeric(x)    # Is it numeric\n## [1] TRUE\nis.logical(x)    # Is it logical\n## [1] FALSE\nis.character(x)    # Is it character\n## [1] FALSE\n\nlength(x)       # How long is it?\n## [1] 3\n\nclass(x)        # What class is it? Atomic class type\n## [1] \"numeric\"\ntypeof(x) # Object type or data structure (matrix, list, array...)\n## [1] \"double\"\nstr(x)          # Structure (Compact display)\n##  num [1:3] 1 2 3\n\n\n\n9.2 Mathematical Summaries\nUse these to calculate statistics on your vectors.\n\nx &lt;- seq(1, 10, 0.3)\n\nmin(x) \n## [1] 1\nmax(x)\n## [1] 10\n\nmean(x)    # Average\n## [1] 5.5\nmedian(x)  # Median\n## [1] 5.5\nsd(x)      # Standard Deviation\n## [1] 2.727636\n\nsummary(x) # Quick summary stats\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##    1.00    3.25    5.50    5.50    7.75   10.00\n\ntable(x)\n## x\n##   1 1.3 1.6 1.9 2.2 2.5 2.8 3.1 3.4 3.7   4 4.3 4.6 4.9 5.2 5.5 5.8 6.1 6.4 6.7 \n##   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1   1 \n##   7 7.3 7.6 7.9 8.2 8.5 8.8 9.1 9.4 9.7  10 \n##   1   1   1   1   1   1   1   1   1   1   1\n\n\n\n9.3 Grouping Data (tapply)\nA powerful function to apply a calculation to groups of data (e.g., â€œFind the mean measurement for Cases vs.Â Controlsâ€).\n\n# Mock data: 6 measurements\nmeasurements &lt;- c(10, 12, 11, 20, 22, 21)\n\n# Groups: 3 Controls, 3 Cases\ngroups &lt;- factor(c(\"Control\", \"Control\", \"Control\", \"Case\", \"Case\", \"Case\"))\n\n\n# Calculate the mean for each group\ntapply(measurements, groups, mean)\n\n   Case Control \n     21      11 \n\n\n\n\n\n\n\n\nNote\n\n\n\nUnderstanding tapply()\nThink of tapply() as an automated assembly line that follows three steps: Split, Apply, and Combine.\nUsage: tapply(X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE)\nThe Break-Down:\nUsing the example: tapply(measurements, groups, mean)\n\nData: measurements\nSplit (The INDEX): R looks at the groups factor. It sees two levels: â€œControlâ€ and â€œCaseâ€. It then â€œsplitsâ€ the measurements into two separate piles based on those labels.\n\nPile 1 (Control): 10, 12, 11\nPile 2 (Case): 20, 22, 21\n\nApply (The FUN): It then takes the function you provided (mean) and goes to each pile individually to calculate the result.\n\nMean of Pile 1 = 11\nMean of Pile 2 = 21\n\nCombine (The Result): It glues those two results back together.\n\n\n\n\n\n9.4 The â€œApplyâ€ Family Cheat Sheet: sapply, lapply, tapply\nThe main difference between these functions is what they take in (Input) and what they give back (Output).\n\n\n\n\n\n\n\n\n\nFunction\nInput\nOutput\nPurpose (â€œIn Plain Englishâ€)\n\n\nlapply\nList or Vector\nList\nâ€œApply this to every item and keep it in a list.â€\n\n\nsapply\nList or Vector\nVector/Matrix\nâ€œApply this to every item and simplify the result.â€\n\n\ntapply\nVector + Factor\nArray/Vector\nâ€œGroup my data by a tag and then calculate.â€",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ± Objects (Data Structures)"
    ]
  },
  {
    "objectID": "WebsiteCodes/05Objects.html#vector-operations",
    "href": "WebsiteCodes/05Objects.html#vector-operations",
    "title": "Objects (Data Structures)",
    "section": "10. Vector Operations",
    "text": "10. Vector Operations\nR is vectorized, meaning mathematical operations are applied to every element at once.\n\nx &lt;- 1:5\ny &lt;- 6:10\n\n# Multiply every element in x by 2\nx * 2\n## [1]  2  4  6  8 10\n\n# Add x and y (element by element)\nx + y\n## [1]  7  9 11 13 15",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ± Objects (Data Structures)"
    ]
  },
  {
    "objectID": "WebsiteCodes/05Objects.html#summary-of-indexing-and-subsetting",
    "href": "WebsiteCodes/05Objects.html#summary-of-indexing-and-subsetting",
    "title": "Objects (Data Structures)",
    "section": "11. Summary of Indexing and subsetting",
    "text": "11. Summary of Indexing and subsetting\nNavigating data in R depends on whether your object is 1-Dimensional (linear) or 2-Dimensional (rectangular). Indexing is the most frequent source of errors for beginners, so here is the master cheat sheet for finding your data.\n\n11.1 The Universal Indexing Rules\nBefore looking at specific structures, remember these three core rules of R:\n\n1-Based Indexing: The first item is always [1], not [0].\nSquare Brackets []: These are the â€œenvelopesâ€ used to hold your address.\nNegative Indices: Using a minus sign (e.g., [-1]) means â€œGive me everything except this position.â€\n\n\n\n11.2 Indexing by Data Structure\n\n\n\n\n\n\n\n\n\n\nStructure\nDimension\nPrimary Method\nExample\nResult\n\n\n\n\nVector\n1D\n[ x ]\nv[1:3]\nReturns the first 3 elements.\n\n\nFactor\n1D\n[ x ]\nf[1]\nReturns the first element + its levels.\n\n\nList\n1D\n[[ x ]] or $\nl[[1]]\nReturns the content of the first â€œdrawer.â€\n\n\nMatrix\n2D\n[row, col]\nm[1, 2]\nValue at Row 1, Column 2.\n\n\nData Frame\n2D\n$ or [row, col]\ndf$age\nReturns the entire â€œageâ€ column as a vector.\n\n\n\n\n\n11.3 Specific Methods & Nuances\n\nThe 2D Coordinate System ([row, col])\nUsed for Matrices and Data Frames. The comma is the most important part!\n\ndf[1, 5]: Specific cell (Row 1, Col 5).\ndf[1, ]: Entire Row (Leave the column space empty).\ndf[, 5]: Entire Column (Leave the row space empty).\n\n\n\nList vs.Â Data Frame Access\nBecause a Data Frame is technically a â€œlist of vectors,â€ it is the most flexible structure for indexing.\n\ndf &lt;- data.frame(\n  ID = c(\"P001\", \"P002\", \"P003\"),\n  Age = c(25, 34, 28),\n  Treatment = c(\"Placebo\", \"Drug\", \"Placebo\")\n)\n\n# By Name ($) â€” Fast and readable\ndf$Treatment\n\n# By Position â€” Useful when you don't know the names but know the order\ndf[, 1]\n\n# By Logical Mask â€” Returns all rows where the Age is over 50\ndf[df$Age &gt; 50, ]",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ± Objects (Data Structures)"
    ]
  },
  {
    "objectID": "WebsiteCodes/03SyntaxOp.html",
    "href": "WebsiteCodes/03SyntaxOp.html",
    "title": "Syntax Operators",
    "section": "",
    "text": "Syntax operators are the specialized symbols and keywords that define how R interprets your code. They handle essential tasks like naming objects, writing notes to yourself, and digging into complex datasets.\nIt includes comment line, assignation, access content, and equal.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ¯ Syntax operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/03SyntaxOp.html#comments-writing-notes-to-your-future-self",
    "href": "WebsiteCodes/03SyntaxOp.html#comments-writing-notes-to-your-future-self",
    "title": "Syntax Operators",
    "section": "1. Comments (#): Writing Notes to Your Future Self",
    "text": "1. Comments (#): Writing Notes to Your Future Self\nComments are used to explain why you wrote a specific line of code. This is vital for reproducibility and collaboration. Anything written after the # symbol is ignored by R during execution.\n\nManual: Type # before your note.\nShortcut (Mac): Cmd + Shift + C\nShortcut (Windows): Ctrl + Shift + C\n\n\n# This is a comment. R will not execute this.\n# \"hello world\"\n\n\n\n\n\n\n\nNote\n\n\n\nThe shortcut is â€œsmart.â€ If you highlight ten lines of code and hit the shortcut, it will comment out all ten lines at once. Hit it again to â€œuncommentâ€ them.\n\n\n\n\n\n\n\n\nNote\n\n\n\nIt doesnâ€™t matter how many # symbols you use.\nR simply looks for the first one on a line and ignores everything to the right of it. You are free to use multiple hashtags to create visual hierarchy in your script:\n\n#-----------------------------------------------------------\n## MAIN SECTION: DATA CLEANING\n#-----------------------------------------------------------\n\n### Step 1: Remove outliers\n# The following line filters out p-values above 0.05\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nBest Practices for Commenting\n\nDonâ€™t explain â€œWhatâ€: R (and yourself) knows what the code is doing.\n\nBad: # Adding 1 to x\n\nExplain â€œWhyâ€: Explain the scientific logic.\n\nGood: # Adjusting for batch effect\n\nUse them as â€œBookmarksâ€: Use long lines of hashtags to separate your â€œLoading Dataâ€ section from your â€œPlottingâ€ section.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ¯ Syntax operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/03SyntaxOp.html#assignment-creating-objects",
    "href": "WebsiteCodes/03SyntaxOp.html#assignment-creating-objects",
    "title": "Syntax Operators",
    "section": "2. Assignment: Creating Objects",
    "text": "2. Assignment: Creating Objects\nAssignment is the process of storing a value (data) inside a named container (an object).\n\n2.1 The Left-Hand Assignment (&lt;-)\nThe standard way to assign values in R is using the &lt;- operator. Think of it as an arrow pointing from the data to the label.\n\n# The convention is to use left hand assignation \nvar1 &lt;- \"hello world\"\nvar1\n\n[1] \"hello world\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nShortcut for &lt;-\nInstead of typing two characters, use these shortcuts to insert the assignment arrow:\n\nMac: Option + - (minus key)\nWindows: Alt + - (minus key)\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nA Note on Coding Style: To Space or Not to Space?\nWhile var1&lt;-â€œhello worldâ€ works, it is a little bit â€œdirtyâ€ and hard to read.\nFollowing the Tidyverse Style Guide, you should always put a space before and after the assignment operator: var1 &lt;- \"hello world\"\n\n\n\n\n2.2 Other Assignment Methods\n\n2.2.1 The Equals Sign (=):\nWhile = works for assignment, R users generally avoid it. In R, = is typically reserved for defining arguments inside a function. Using it for general assignment is considered poor style.\n\n# It is also possible to use the '=' sign, but is NOT a good practice\nvar1 = \"hello world\"\nvar1\n\n[1] \"hello world\"\n\n\n\n\n2.2.2 Right-Hand Assignment (-&gt;):\nYou can technically point the arrow the other way: \"data\" -&gt; var1.\nThis is rarely used but can be helpful at the end of a long pipe (|&gt;) if you decide to save the final result into a new variable.\n\n\"hello world\" -&gt; var1\nvar1\n\n[1] \"hello world\"\n\n\n\n\n\n2.3 Printing Variables\nOnce you have stored data in a variable, there are several ways to â€œcallâ€ it back to the console:\n\n2.3.1 Direct Call\nSimply type the name. This is the most common method during interactive analysis.\n\n\"hello world!\"\n\n[1] \"hello world!\"\n\n\n\n\n2.3.2 Using Function print() and cat()\nprint(): Explicitly prints the object. This is often used inside â€œloopsâ€ or complex functions where R might not automatically show the output.\ncat(): Short for â€œconcatenate.â€ It prints the raw text without the [1] index marker or quotes. It is great for creating clean, human-readable messages.\n\nvar1 &lt;- \"McGill\"\nprint(var1)\n\n[1] \"McGill\"\n\n\n\nvar1 &lt;- \"McGill\"\ncat(var1)\n\nMcGill",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ¯ Syntax operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/03SyntaxOp.html#access-content",
    "href": "WebsiteCodes/03SyntaxOp.html#access-content",
    "title": "Syntax Operators",
    "section": "3. Access Content ($)",
    "text": "3. Access Content ($)\nThe $ operator is one of the most powerful symbols in R. It allows you to â€œreach insideâ€ a complex object (like a Data Frame or a List) and extract a specific column or element by its name.\nExample: The iris Dataset\nThe iris dataset is a built-in collection of measurements for 150 flowers. It includes variables like Sepal.Length, Petal.Length, and Species. To look at only the species column, we use the $ operator.\n\n# Show the first 6 rows of the dataset\nhead(iris)\n\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa\n\n# Extract only the \"Species\" column\niris$Species\n\n  [1] setosa     setosa     setosa     setosa     setosa     setosa    \n  [7] setosa     setosa     setosa     setosa     setosa     setosa    \n [13] setosa     setosa     setosa     setosa     setosa     setosa    \n [19] setosa     setosa     setosa     setosa     setosa     setosa    \n [25] setosa     setosa     setosa     setosa     setosa     setosa    \n [31] setosa     setosa     setosa     setosa     setosa     setosa    \n [37] setosa     setosa     setosa     setosa     setosa     setosa    \n [43] setosa     setosa     setosa     setosa     setosa     setosa    \n [49] setosa     setosa     versicolor versicolor versicolor versicolor\n [55] versicolor versicolor versicolor versicolor versicolor versicolor\n [61] versicolor versicolor versicolor versicolor versicolor versicolor\n [67] versicolor versicolor versicolor versicolor versicolor versicolor\n [73] versicolor versicolor versicolor versicolor versicolor versicolor\n [79] versicolor versicolor versicolor versicolor versicolor versicolor\n [85] versicolor versicolor versicolor versicolor versicolor versicolor\n [91] versicolor versicolor versicolor versicolor versicolor versicolor\n [97] versicolor versicolor versicolor versicolor virginica  virginica \n[103] virginica  virginica  virginica  virginica  virginica  virginica \n[109] virginica  virginica  virginica  virginica  virginica  virginica \n[115] virginica  virginica  virginica  virginica  virginica  virginica \n[121] virginica  virginica  virginica  virginica  virginica  virginica \n[127] virginica  virginica  virginica  virginica  virginica  virginica \n[133] virginica  virginica  virginica  virginica  virginica  virginica \n[139] virginica  virginica  virginica  virginica  virginica  virginica \n[145] virginica  virginica  virginica  virginica  virginica  virginica \nLevels: setosa versicolor virginica\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe head() Function\nThe head() function is a â€œquick lookâ€ tool. It returns the first few rows of a dataset (default is 6) so you can inspect your data without flooding your console with thousands of lines.\nConversely, tail() shows you the last few rows.\nRemember, you can always type ?head in your Console to see the full documentation.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ¯ Syntax operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/03SyntaxOp.html#the-equal-operator",
    "href": "WebsiteCodes/03SyntaxOp.html#the-equal-operator",
    "title": "Syntax Operators",
    "section": "4. The Equal Operator (=)",
    "text": "4. The Equal Operator (=)\nIn R, the single equals sign (=) has two primary roles, but they are not created equal.\n\n4.1 Assignment (Not Recommended)\nWhile = can be used to assign a value to a variable, R users generally avoid this. In the R community, using = for assignment is considered poor style because it can be confused with mathematical equality or function arguments.\nAlways prefer &lt;- for creating variables.\n\n# It is also possible to use the '=' sign, but is NOT a good practice\nvar1 = \"hello world\"\nvar1\n\n[1] \"hello world\"\n\n\n\n\n4.2 Defining Function Arguments (Recommended)\nThe â€œcorrectâ€ and most common use of the = sign in R is to define arguments inside a function. This tells the function exactly how you want it to behave.\nExample: The paste() Function\nThe paste() function joins multiple pieces of text together. It uses an argument called sep to decide what character should go between the pieces.\n\ncal &lt;- 1 + 3\n\n# Using '=' to define the separator argument\npaste(\"The output of 1 + 3\", cal,\n      sep = \" = \")\n\n[1] \"The output of 1 + 3 = 4\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nDeep Dive: ?paste\nIf you look at the help documentation for paste(), you will see the usage and arguments explanations:\nUsage\npaste(â€¦, sep = â€ â€œ, collapse = NULL)\nArguments\nsep: a character string to separate the terms.\nBy using sep = â€ = â€œ, we are overriding the default space (â€ â€œ) and telling R to put an equals sign between our text and our result.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ¯ Syntax operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/01AtomicClasses.html",
    "href": "WebsiteCodes/01AtomicClasses.html",
    "title": "Atomic Classes (Data Types)",
    "section": "",
    "text": "Atomic classes are the fundamental data type found in R. All subsequent data structures are used to store entries of different atomic classes.\nIf an Excel spreadsheet is your storage system, the Atomic Class is the actual â€œstuffâ€ written inside each cellâ€”whether itâ€™s a number, a word, or a simple â€œTrue/False.â€",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ­ Atomic Classes (Data Types)"
    ]
  },
  {
    "objectID": "WebsiteCodes/01AtomicClasses.html#character",
    "href": "WebsiteCodes/01AtomicClasses.html#character",
    "title": "Atomic Classes (Data Types)",
    "section": "1. Character",
    "text": "1. Character\nThe Character class represents text data. This can be a single letter, a word, or an entire sentence. In R, anything wrapped in quotation marks is treated as text.\n\nclass(\"a\")\n\n[1] \"character\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nUnderstanding the class() Function\nFunctions: In R, a function typically follows the format function_name().\nArguments: The information you put inside the parentheses () is called an argument. The function takes that argument, processes it, and returns a result.\nTesting Types: The class() function is your go-to tool for identifying the data type of any object or value.\n\n\n\n\n\n\n\n\nTip\n\n\n\nEfficiency Tip: The Quotation Shortcut\nIn RStudio, you donâ€™t have to manually type quotation marks at the beginning and end of every word or sentence. There is a â€œsurroundâ€ shortcut that handles this for you:\n\nHighlight the word, number, or sentence you want to wrap in quotes.\nPress the Quote Key:\n\nOn both Mac and Windows, simply hit the \" (Shift + ') or ' key.\n\nResult: RStudio will automatically place a quotation mark at the start and the end of your selection.\n\nWait, where else does this work?\nThis shortcut also works for other â€œpairingâ€ symbols in RStudio:\n\nParentheses: Highlight text and press ( to get (text).\nBrackets: Highlight text and press [ to get [text].\nBraces: Highlight text and press { to get {text}.\n\nNote: This is a specific feature of the RStudio IDE. While it works in some modern code editors (like VS Code), it generally will not work in standard software like Microsoft Word or PowerPoint.\n\n\n\n1.1 Working with Strings and Sentences\nR can handle strings of any length, from a single word to a full paragraph.\n\nclass(\"Hello World!\")\n\n[1] \"character\"\n\n\nYou can even store long blocks of text, such as this land acknowledgement:\n\nclass(\"McGill University is on land which has long served as a site of meeting and exchange amongst Indigenous peoples, including the Haudenosaunee and Anishinabeg nations. We acknowledge and thank the diverse Indigenous peoples whose presence marks this territory on which peoples of the world now gather.\")\n\n[1] \"character\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nSingle vs.Â Double Quotes\nIn R, there is no functional difference between using double quotes (â€ â€œ) and single quotes (â€™ â€™). However, double quotes are the standard convention in the R community.\nThe Rule for â€œNestingâ€ Quotes: If your text contains a quote, you must use the other type of quotation mark on the outside so R knows where the string starts and ends.\n\n\n\n# If the text has single quotes, use double quotes outside\nclass(\"It's a beautiful day in Montreal.\")\n\n[1] \"character\"\n\n# If the text has double quotes, use single quotes outside\nclass('We said, \"R is powerful.\"')\n\n[1] \"character\"\n\n\n\n\n1.2 Numbers as Characters\n\n\n\n\n\n\nNote\n\n\n\nIt is important to remember that if you wrap a number in quotes, R will treat it as text, not as a mathematical value.\nYou cannot perform math (like addition) on a character â€œ1â€.\n\n\n\nclass(\"1\")\n\n[1] \"character\"\n\n\n\n\n1.3 Common Error: Variables vs.Â Literal Text\nOne of the most frequent mistakes for beginners is forgetting the quotation marks. This is where the difference between a Value and a Variable becomes critical.\nIf you try to check the class of a without quotes, you will encounter an error:\n\nclass(a)\n\nError:\n! object 'a' not found\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhy did this fail?\nWithout the quotation marks, R doesnâ€™t see the letter â€œaâ€.\nInstead, it looks for an object or variable named a on your workbench (Environment). Since we havenâ€™t created a variable named a yet, R reports: Error: object â€˜aâ€™ not found.\n\n\n\n\n1.4 Summary\n\nAnything inside quotation marks is aÂ Character.\nThis includes numbers, symbols, and entire paragraphs.\nCharacters are the primary way we store metadata (like â€œControlâ€ vs â€œTreatmentâ€ groups) in bioinformatics.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ­ Atomic Classes (Data Types)"
    ]
  },
  {
    "objectID": "WebsiteCodes/01AtomicClasses.html#numeric",
    "href": "WebsiteCodes/01AtomicClasses.html#numeric",
    "title": "Atomic Classes (Data Types)",
    "section": "2. Numeric",
    "text": "2. Numeric\nIn R, any numberâ€”with or without decimalsâ€”is recognized as the Numeric data type by default.\n\n2.1 Whole Numbers vs.Â Decimals\nEven if you type a whole number like 1, 234, or 100, R stores them as â€œNumericsâ€ (specifically Doubles) unless you explicitly tell it otherwise.\n\nclass(123)\n\n[1] \"numeric\"\n\n\n\nclass(2.0)\n\n[1] \"numeric\"\n\n\n\n\n2.2 Mathematical Constants\nR also has built-in objects for common mathematical constants, such as Ï€.\n\npi\n\n[1] 3.141593\n\nclass(pi)\n\n[1] \"numeric\"\n\n\n\n\n\n\n\n\nNoteBuilt-in Constants\n\n\n\nR includes several predefined objects for mathematical and logical use. pi is the most common, but you will also encounter others like Inf (Infinity) and NaN (Not a Number) during your analysis.\n\n\n\n\n2.3 Numeric vs.Â Character: The Quote Rule\nOne of the most important habits to build is checking whether your number is being read as math or text.\n\n3.14\n\n[1] 3.14\n\n\n\n\"3.14\"\n\n[1] \"3.14\"\n\n\n\nclass(3.14)\n## [1] \"numeric\"\nclass(\"3.14\")\n## [1] \"character\"\n\n\n\n\n\n\n\nNoteNotice the Difference?\n\n\n\nWhen you run code, R shows you exactly how it â€œseesâ€ your input:\n\nInput 3.14: R returns 3.14. It treats this as a value you can add, subtract, or multiply.\nInput â€œ3.14â€: R returns â€œ3.14â€. Because of the quotation marks, R treats this as a Character string. You cannot perform math on this; to R, this is no different than the word â€œApple.â€\n\n\n\n\n\n2.4 How Numbers are Stored: â€œDoublesâ€\nWhy does R call a whole number â€œNumericâ€ instead of an â€œIntegerâ€?\nBy default, R uses Double-precision floating-point format (often called â€œDoublesâ€) to store numbers.\n\nPrecision: Each â€œDoubleâ€ is stored using 8 bytes of memory and is accurate up to approximately 16 significant decimal digits.\nFlexibility: Storing numbers with decimals by default allows R to handle complex division and scientific calculations without losing data.\n\n\n\n\n\n\n\nNote\n\n\n\nForcing an Integer\nIf you specifically need a whole number to be stored as an Integer (which uses less memory), you must add an L after the number: class(1L) will return \"integer\".\nHowever, for 99% of medical research tasks, the default Numeric setting is exactly what you need.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ­ Atomic Classes (Data Types)"
    ]
  },
  {
    "objectID": "WebsiteCodes/01AtomicClasses.html#integer",
    "href": "WebsiteCodes/01AtomicClasses.html#integer",
    "title": "Atomic Classes (Data Types)",
    "section": "3. Integer",
    "text": "3. Integer\nIntegers are numbers that do not have a decimal component.\nWhile R defaults to â€œNumericâ€ (Double) for almost everything, you can explicitly tell R to store a number as an Integer by adding the suffix *L* after the value.\n\nclass(1234L)\n\n[1] \"integer\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhy the â€œLâ€?\nThe â€œLâ€ stands for Long, a legacy term from older programming languages (like C) used to denote a specific amount of computer memory. In modern R, it simply tells the computer: â€œStore this as a whole number, not a decimal.â€\nWhere the Integer data type is necessary\nIn most day-to-day experimental medicine tasks, you wonâ€™t need to worry about this.\nHowever, there are specific scenarios where using Integers is critical:\n\nMemory Efficiency in â€œBig Dataâ€: A â€œDoubleâ€ (Numeric) takes up 8 bytes of memory, while an â€œIntegerâ€ takes up only 4 bytes.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ­ Atomic Classes (Data Types)"
    ]
  },
  {
    "objectID": "WebsiteCodes/01AtomicClasses.html#complex",
    "href": "WebsiteCodes/01AtomicClasses.html#complex",
    "title": "Atomic Classes (Data Types)",
    "section": "4. Complex",
    "text": "4. Complex\nA complex value in R is defined via the pure imaginary value i.\n\nclass(2i)\n\n[1] \"complex\"",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ­ Atomic Classes (Data Types)"
    ]
  },
  {
    "objectID": "WebsiteCodes/01AtomicClasses.html#logical",
    "href": "WebsiteCodes/01AtomicClasses.html#logical",
    "title": "Atomic Classes (Data Types)",
    "section": "5. Logical",
    "text": "5. Logical\nThe Logical data type represents binary outcomes: TRUE or FALSE.\nFor example, in research, these are the outputs of logical tests (e.g., â€œIs this patientâ€™s BMI &gt; 30?â€).\n\nclass(TRUE)\n\n[1] \"logical\"\n\nclass(FALSE)\n\n[1] \"logical\"\n\n\n\n5.1 The Math of Logic\nOne of the most powerful features of logical values is their underlying numeric value:\n\nTRUE is treated as 1.\nFALSE is treated as 0.\n\nThis allows you to quickly count occurrences in a dataset. For example, if you want to know how many patients in your study are â€œMales,â€ you can simply â€œsumâ€ a logical vector of their sex, and R will give you the total count.\n\n\n5.2 Abbreviations: T and F\nR allows you to use T and F as shorthand for TRUE and FALSE.\n\nclass(T)\n\n[1] \"logical\"\n\nclass(F)\n\n[1] \"logical\"\n\n\n\n\n\n\n\n\nWarning\n\n\n\nA Note on Best Practices\nWhile using T and F is a common â€œlazyâ€ shortcut, most professional programmers recommend using the full words TRUE and FALSE.\nWhy?\nBecause in R, T and F are technically variables that can be overwritten (e.g., someone could accidentally set T &lt;- 0), whereas the full words TRUE and FALSE are â€œreservedâ€ and cannot be changed. For reproducible research, stick to the full words!\n\n\n\n\n5.3 Case Sensitivity and Common Errors\nR is strictly case-sensitive. The logical values must be in all caps.\nIf you use â€œSentence caseâ€ (e.g., True), R will assume you are looking for a variable with that name and throw an error.\n\nclass(True)\n\nError:\n! object 'True' not found\n\nclass(False)\n\nError:\n! object 'False' not found\n\n\n\n\n\n\n\n\nNote\n\n\n\nSummary\nThere are only two ways to correctly define a logical data type:\n\nTRUE / FALSE (Full words, all upper case).\nT / F (Single letters, upper case).\n\n\n\n\n\n5.4 Application: Filtering Data\nIn bioinformatics, you will use logicals constantly to filter your data. For example:\ngene_expression &gt; 10 returns a list of TRUE/FALSE values.\nYou can then use that list to keep only the genes where the result was TRUE.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ­ Atomic Classes (Data Types)"
    ]
  },
  {
    "objectID": "WebsiteCodes/01AtomicClasses.html#missing-value",
    "href": "WebsiteCodes/01AtomicClasses.html#missing-value",
    "title": "Atomic Classes (Data Types)",
    "section": "6. Missing Value",
    "text": "6. Missing Value\nIn R, missing data is represented by the logical constant NA (Not Available). It acts as a placeholder to indicate that a data entry is simply not there.\nUseful for manipulating data sets where missing entries are common.\n\nNA\n\n[1] NA\n\nclass(NA)\n\n[1] \"logical\"\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhy use NA instead of 0?\nIt is a common mistake in research to fill missing entries with 0.\nHowever, in a medical context, zero is a value (e.g., zero glucose, zero heart rate), whereas NA is an absence of data (e.g., the patient missed their appointment). Treating an NA as a 0 will incorrectly skew your averages and invalidate your statistical tests.\n\n\n\n6.1 How is this helpful for your research?\n\nAutomated Data Handling\nWhen you import an Excel sheet into R, empty cells are automatically converted to NA. Most R functions are designed to handle these gracefully. For example, when calculating the average weight of a group, you can tell R to ignore the missing entries: mean(weights, na.rm = TRUE)\nEfficient Quality Control (QC)\nInstead of scanning a spreadsheet with thousands of rows by eye, you can use R to:\n\nCount exactly how many entries are missing in a clinical trial.\nIdentify which patients have incomplete gene expression profiles.\nFilter your dataset to remove any rows or columns that contain NA values in just one line of code (e.g., na.omit()).\n\nTransparency and Reproducibility\nUsing NA keeps your data â€œhonest.â€ It is a professional standard to keep notes on why data is missing (e.g., â€œsample contaminatedâ€ or â€œpatient withdrewâ€). By keeping NA in your raw data and handling it with code, you create a clear, reproducible trail of how you arrived at your final results.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ­ Atomic Classes (Data Types)"
    ]
  },
  {
    "objectID": "WebsiteCodes/02ArithmeticOp.html",
    "href": "WebsiteCodes/02ArithmeticOp.html",
    "title": "Arithmetic Operators",
    "section": "",
    "text": "An operator is a symbol or keyword that tells the computer what operation it should perform on values or variables. The arithmetic operators perform mathematical calculations.\nAt its most basic level, R is a powerful scientific calculator. It handles standard arithmetic as well as complex matrix operations required for bioinformatics.\nThe fundamental operations include addition, subtraction, multiplication, and division.\nBeyond these, R handles powers (exponents), modulus (remainder from division), integer division, scalar multiplication, and matrix algebra.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ® Arithmetic operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/02ArithmeticOp.html#basic-arithmetic",
    "href": "WebsiteCodes/02ArithmeticOp.html#basic-arithmetic",
    "title": "Arithmetic Operators",
    "section": "1. Basic Arithmetic",
    "text": "1. Basic Arithmetic\nStandard operations follow the symbols you are likely already familiar with:\n\n\n\nOperation\nOperator\nExample\n\n\n\n\nAddition\n+\n2 + 100000\n\n\nSubtraction\n-\n3 - 5\n\n\nMultiplication\n*\n71 * 9\n\n\nDivision\n/\n90 / 19\n\n\nPower\n^\n2 ^ 3\n\n\n\nExamples in Action\n\n# Addition: Add 2 and 100,000\n2 + 100000\n## [1] 100002\n\n# Subtraction: Subtract 5 from 3\n3 - 5\n## [1] -2\n\n# Multiplication: Multiply 71 by 9\n71 * 9\n## [1] 639\n\n# Division with Order of Operations\n90 / ((3 * 5) + 4)\n## [1] 4.736842\n\n# Power: 2 to the power of 3\n2 ^ 3\n## [1] 8\n\n\n\n\n\n\n\nNote\n\n\n\nA Note on Coding Style: To Space or Not to Space?\nIn R, spaces around operators are generally ignored by the computer, but they matter a lot for human readability.\n\nStandard Style (Recommended): Use a space before and after the symbol: 1 + 1. This is the professional standard (often called the Tidyverse Style Guide). It makes your code much easier to read.\nCompact Style: No spaces: 1+1. This works perfectly, but can look â€œcrampedâ€ in long equations.\nInconsistent Style (Avoid): Using space on only one side, like 1+ 1 or 1 +1.\n\nProfessional Tip\nWhile R will run your code regardless of the spacing, consistency is key. Keeping a clean, spaced-out style helps you (and your PI) catch errors more easily when reviewing your analysis later.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ® Arithmetic operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/02ArithmeticOp.html#what-can-be-used-with-arithmetic-operations",
    "href": "WebsiteCodes/02ArithmeticOp.html#what-can-be-used-with-arithmetic-operations",
    "title": "Arithmetic Operators",
    "section": "2. What can be used with Arithmetic Operations?",
    "text": "2. What can be used with Arithmetic Operations?\nIn research, you wonâ€™t just be typing raw numbers. You will frequently perform calculations using objects (variables) that store your data. You can mix and match numbers and objects freely.\nExample: Number with Object\n\nnum &lt;- 2 \n1 + num\n\n[1] 3\n\n\nExample: Object with Object\n\nnum1 &lt;- 2 \nnum2 &lt;- 3\nnum1 * num2\n\n[1] 6\n\n\n\n\n\n\n\n\nNote\n\n\n\nWait, what is &lt;- ?\nIn the code above, we used the &lt;- symbol. This is an Assignment Operator. It is used to store data into the object it points to. Think of it as an arrow putting a value into a labeled box.\nWe will explore this in depth in the next chapter, but for now, just know that num1 &lt;- 2 means the box labeled num1 now contains the number 2.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ® Arithmetic operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/02ArithmeticOp.html#operator-precedence",
    "href": "WebsiteCodes/02ArithmeticOp.html#operator-precedence",
    "title": "Arithmetic Operators",
    "section": "3. Operator Precedence",
    "text": "3. Operator Precedence\nNot all operators are created equal.\nR follows a specific order of operations (similar to high school mathematics, often called PEMDAS). For example, multiplication (*) and division (/) will always be performed before addition (+) and subtraction (-).\n\nresults1 &lt;- 1 + 2 * 3\nresults2 &lt;- (1 + 2) * 3\n\nresults1\n## [1] 7\nresults2\n## [1] 9\n\n\n\n\n\n\n\nTip\n\n\n\nBest Practice: When in doubt, use parentheses (). They have the highest precedence and ensure R calculates your formula exactly how you intended.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ® Arithmetic operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/02ArithmeticOp.html#vectorized-operators",
    "href": "WebsiteCodes/02ArithmeticOp.html#vectorized-operators",
    "title": "Arithmetic Operators",
    "section": "4. Vectorized Operators",
    "text": "4. Vectorized Operators\nUnlike many other programming languages, R is designed specifically for statistics. This means its operators are vectorized.\nIf you have a list (vector) of 1,000 patient ages and you want to add 10 to all of them, you donâ€™t need to write a complex loop. R simply applies the operation to every single value in the list simultaneously.\n\n# Example: Adding 10 to a vector of three ages\nages &lt;- c(20, 30, 40)\nages + 10\n\n[1] 30 40 50\n\n\n\n\n\n\n\n\nNote\n\n\n\nIn most programming languages (like C++ or Java), if you want to perform math on a list of numbers, you have to write a â€œFor-Loop.â€ This tells the computer: â€œLook at the first number, add 10, save it. Now move to the second number, add 10, save itâ€¦â€\nTo add 10 to each without vectorization, you have to create a container and manually iterate through every position, be like:\n\nages &lt;- c(25, 30, 45)\nnew_ages &lt;- c() # Create an empty container\n\n# The Loop: Adding 10 one-by-one\nfor (i in 1:length(ages)) {\n  new_ages[i] &lt;- ages[i] + 10\n}\n\nprint(new_ages)\n\n[1] 35 40 55",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ® Arithmetic operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/04LogicalOp.html",
    "href": "WebsiteCodes/04LogicalOp.html",
    "title": "Comparison Operators and Logical Operators",
    "section": "",
    "text": "Comparison operators are used to compare two values.\nWhen you run a comparison, R evaluates the statement and returns a Logical value: either TRUE or FALSE.\nLogical operators allow you to combine multiple comparison statements into a single test. This is essential for complex data filtering.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ° Logical operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/04LogicalOp.html#comparison-operators",
    "href": "WebsiteCodes/04LogicalOp.html#comparison-operators",
    "title": "Comparison Operators and Logical Operators",
    "section": "1. Comparison operators",
    "text": "1. Comparison operators\n\n1.1 ==\nIn R, == is a logical operator for comparison. == asks: â€œIs A exactly equal to B?â€\n\n# Comparing numbers\n10 == 2\n\n[1] FALSE\n\n# Comparing text (Case sensitive!)\n\"McGill\" == \"mcgill\"\n\n[1] FALSE\n\n\n\n\n\n\n\n\nWarning\n\n\n\nThe Most Common R Error: = vs ==\n= (or &lt;-) is for Assignment: You are telling R that a variable equals a value.\n== is for Comparison: You are asking R if two things are equal.\nIncorrect Demonstrations\n\nAttempting to assign to a literal number\n\n# ERROR: This sounds like you are trying to force the number 10 \n# to take on the value 2. R will block this.\n10 = 2\n\nError in `10 = 2`:\n! invalid (do_set) left-hand side to assignment\n\n\nConfusing Variables with Text\n\n# ERROR: This creates a NEW variable named McGill and stores \"mcgill\" in it.\n# It does NOT check if they are the same.\nMcGill = \"mcgill\"\n\n# To actually COMPARE them, you must use double equals and quotes for both:\n\"McGill\" == \"mcgill\"\n\n[1] FALSE\n\n\n\n\n\n\n\n1.2 !=\nIn R, the exclamation mark ! stands for â€œNOTâ€. When combined with the equals sign, != checks if two values are different. != asks: â€œIs A different from B?â€\n\nIt returns TRUE if the values are not the same (are different).\nIt returns FALSE if they are the same (are not different).\n\n\n# Is 10 equal to 2? (False)\n10 == 2\n\n[1] FALSE\n\n# Is 10 different from 2? (True)\n10 != 2\n\n[1] TRUE",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ° Logical operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/04LogicalOp.html#logical-operators",
    "href": "WebsiteCodes/04LogicalOp.html#logical-operators",
    "title": "Comparison Operators and Logical Operators",
    "section": "2. Logical operators",
    "text": "2. Logical operators\n\n\n\n\n\n\n2.1 &\nThe â€œANDâ€ Operator (&): Use this when your condition must meet all criteria simultaneously.\n\nage &lt;- 65\nbmi &lt;- 32\n\n# Is the patient over 60 AND obese (BMI &gt; 30)?\nage &gt; 60 & bmi &gt; 30\n\n[1] TRUE\n\n\n\n\n2.2 |\nThe â€œORâ€ Operator (|): Use this when meeting any one of the criteria is sufficient.\n\n# Is the flower species either 'setosa' OR 'versicolor'?\nspecies &lt;- \"setosa\"\nspecies == \"setosa\" | species == \"versicolor\"\n\n[1] TRUE\n\n\n\n\n\n\n\n\nNote\n\n\n\nKeyboard Tip: How to type |?\nLook for the key with the backslash \\ (usually above the Return/Enter key).\n\nMac & Windows: Press Shift + \\\n\n\n\n\n\n2.3 !\nThe â€œNOTâ€ Operator (!): This exclamation mark is used to reverse a logical value or exclude specific data points.\n\n!TRUE\n\n[1] FALSE\n\n\n\ncontrol_group &lt;- FALSE\n# Is the sample NOT in the control group?\n!control_group\n\n[1] TRUE\n\n\n\n\n2.4 The Membership Operator (%in%)\nThe %in% operator (often called â€œcontainsâ€) is extremely useful when you want to check if a value belongs to a large list or group.\nExample: Searching for Genes Imagine you have a list of â€œGenes of Interestâ€ for your diabetes research. You can check if a specific gene is in that list without writing many OR statements.\n\ndiabetes_genes &lt;- c(\"INS\", \"GCK\", \"KCNJ11\", \"SLC30A8\")\n\n# Is 'INS' (Insulin) in our list?\n\"INS\" %in% diabetes_genes\n## [1] TRUE\n\n# Is 'SOX2' in our list?\n\"SOX2\" %in% diabetes_genes\n## [1] FALSE",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ° Logical operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/04LogicalOp.html#extended-reading-what-is-the-difference-between-and",
    "href": "WebsiteCodes/04LogicalOp.html#extended-reading-what-is-the-difference-between-and",
    "title": "Comparison Operators and Logical Operators",
    "section": "3. Extended Reading: what is the difference between `&and&&`?",
    "text": "3. Extended Reading: what is the difference between `&and&&`?\nIn R, you will sometimes see the double operator (&& and ||). While they look similar, they behave very differently under the hood:\n\n\n\n\n\n\n\n\n\nOperator\nType\nBehavior\nBest Use Case\n\n\n&\nVectorized\nCompares every element in a list.\nData Filtering (e.g., filtering a whole column of 1,000 patients).\n\n\n&&\nControl Flow\nOnly looks at the first element and ignores the rest.\nif statements inside functions where you only expect one TRUE/FALSE.\n\n\n\nIn this workshop (and for 90% of data analysis), you should always use the single & and |. The double versions are advanced tools used mostly by package developers to make code run slightly faster in specific scenarios.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Types and Data Structures",
      "ğŸ° Logical operators"
    ]
  },
  {
    "objectID": "WebsiteCodes/06ConditionalStat.html#the-logic-of-decision-making",
    "href": "WebsiteCodes/06ConditionalStat.html#the-logic-of-decision-making",
    "title": "Conditional Statements",
    "section": "1. The Logic of Decision Making",
    "text": "1. The Logic of Decision Making\nIn programming, Conditional Statements allow your code to branch. Instead of running every line of code from top to bottom, R will only run specific sections if a condition is met.\n\n1.1 Binary Conditions (if â€¦ else)\nThis is used for simple â€œYes/Noâ€ or â€œEither/Orâ€ logic.\nThe Structure (Pseudo-code):\n\nif (condition) {\n  # Perform this task if condition is TRUE\n} else {\n  # Perform this task if condition is FALSE\n}\n\nExample:\n\nx &lt;- 5\n\nif (x &gt; 5) {\n  # If the number is greater than 5, get its square\n  x^2\n} else {\n  # If not, multiply it by 2\n  x * 2\n}\n\n[1] 10\n\n\n\n\n\n\n\n\nNote\n\n\n\nBecause the condition x &gt; 5 evaluated to FALSE (since 5 is equal to 5, not strictly greater than 5), R skipped the first block and jumped straight to the else block.\n\n\n\n\n1.2 Multi-branch Conditions (else if)\nWhen your logic is more complex than a simple binary choice, you can chain conditions together. You can have as many else if blocks as you need.\nThe Structure (Pseudo-code):\n\nif (condition_1) {\n  # Perform Task A\n} else if (condition_2) {\n  # Perform Task B\n} else if (condition_3) {\n  # Perform Task C\n} else {\n  # Perform Task D if NONE of the above were TRUE\n}\n\n\nx &lt;- 7\n\nif (x &gt; 5 && x &lt; 10) {\n  # If x is between 5 AND 10\n  x^2\n} else if (x &lt; 0 || x &gt; 10) {\n  # If x is negative OR greater than 10\n  -x\n} else {\n  # For everything else (like 0, 1, 2, 3, 4, 5)\n  x * 2\n}\n\n[1] 49",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Control Structures and Functions",
      "ğŸ² Conditional Statements"
    ]
  },
  {
    "objectID": "WebsiteCodes/06ConditionalStat.html#pro-tips-for-conditionals",
    "href": "WebsiteCodes/06ConditionalStat.html#pro-tips-for-conditionals",
    "title": "Conditional Statements",
    "section": "2. Pro-Tips for Conditionals",
    "text": "2. Pro-Tips for Conditionals\n\n2.1 & vs && (and | vs ||)\nYou might have noticed the use of double symbols (&& and ||) in the example above. In R, there is a small but important difference:\n\nSingle (&, |): These are Vectorized. Use these when comparing entire columns of data (e.g., filtering a Data Frame).\nDouble (&&, ||): These are Short-circuiting. They only look at the first element of a vector. They are faster and preferred inside if statements where you are only checking one value at a time.\n\n\n\n2.2 The â€œMissingâ€ Else\nThe else block is optional. If you donâ€™t provide one and the if condition is FALSE, R will simply skip the block and move to the next line of code.\n\n\n2.3 Indentation Matters for Humans!\nWhile R is â€œspace-insensitiveâ€ (it doesnâ€™t care if your code is a messy pile of text), humans are not. We use indentation to show the hierarchy of logic.\nIt is standard practice to indent the code inside the curly braces { }. This makes it immediately obvious which code belongs to which condition.\n\n\n\n\n\n\nTip\n\n\n\nThe RStudio Secret\nDonâ€™t worry about manually hitting the spacebar! RStudio is designed to help you.\n\nAuto-indent: When you type a { and hit Enter, RStudio automatically adds the correct gap.\nThe â€œRe-formatâ€ Trick: If your code looks messy, you donâ€™t even need to copy-paste. Simply highlight the code and press Ctrl + Shift + A (Windows) or Cmd + Shift + A (Mac). RStudio will instantly clean up the spacing and indentation for you.\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nThe styler Package\nIn professional programming, we often use a package called styler.\nIt acts like a â€œgrammar checkerâ€ for your code, ensuring it follows the tidyverse style guide used by data scientists at NASA, Google, and beyond.\n\n\n\n\n2.4 Best Practices for Conditional Logic\n\nThe MECE Principle\nWhen designing your logic, try to follow the MECE principle: Mutually Exclusive, Collectively Exhaustive.\n\nMutually Exclusive: Your conditions shouldnâ€™t overlap. A number shouldnâ€™t be able to trigger both the if and the else if block at the same time.\nCollectively Exhaustive: You have considered all possibilities. This is why a final else block is so importantâ€”it acts as a â€œsafety netâ€ for any data you didnâ€™t expect.\n\n\n\nThe Power of Comments\nIn bioinformatics, your â€œConditionsâ€ are often based on scientific thresholds (e.g., p-value &lt;0.05 or Log2FoldChange &gt;2).\nAlways write a comment explaining why you chose that threshold. Future you will thank you when youâ€™re writing the â€œMethodsâ€ section of your paper!",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Control Structures and Functions",
      "ğŸ² Conditional Statements"
    ]
  },
  {
    "objectID": "WebsiteCodes/08NewFunctions.html#customize-your-own-functions",
    "href": "WebsiteCodes/08NewFunctions.html#customize-your-own-functions",
    "title": "Customize Your Own Functions",
    "section": "1. Customize Your Own Functions",
    "text": "1. Customize Your Own Functions\n\n\n\n\n\nWriting functions is the best way to keep your code DRY (Donâ€™t Repeat Yourself). If you find yourself copy-pasting code three times, itâ€™s time to write a function.\n\nThe Anatomy of a Function\nA function has three parts:\n\nInput (Arguments): What the function needs to work (e.g., a vector of numbers).\nBody: The actual code/math being performed.\nOutput (Return): What the function gives back to you.\n\n\n# Example: Creating a manual version of the 'mean' function\nnew_mean &lt;- function(values) {\n  # The 'Body'\n  result &lt;- sum(values) / length(values)\n  \n  # The 'Return' (Output)\n  return(result)\n}\n\n# Test it out\nx &lt;- 1:5\nnew_mean(x)\n\n[1] 3\n\n\n\n\n\n\n\n\nNotePro-Tip: When to use return()\n\n\n\nIn R, the function will automatically return the very last line of code executed inside the braces. However, using the explicit return() function is a â€œBest Practiceâ€ because it makes it much clearer to other researchers exactly what your function is providing.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Control Structures and Functions",
      "ğŸ´ Create New Functions"
    ]
  },
  {
    "objectID": "WebsiteCodes/10RWData.html#the-working-directory",
    "href": "WebsiteCodes/10RWData.html#the-working-directory",
    "title": "Reading/Writing Data",
    "section": "0. The Working Directory",
    "text": "0. The Working Directory\nThe Working Directory is the specific folder on your computer where R is currently â€œlookingâ€ for files. Think of it as Râ€™s â€œhome base.â€\n\ngetwd(): Run this in the console to see your current â€œhome baseâ€ address.\nsetwd(): Use this to change where R is looking.\n\n\n0.1 How to Find Your Current â€œHome Baseâ€\nThere are two main ways to check where R is looking:\n\nUsing Code: Run getwd() in the console. R will return the full â€œGPS addressâ€ (path) of your current location.\nUsing Your Eyes: Look at the top of your Console panel. Right next to your R version info, you will see a file path (often starting with ~/).\n\n\n\n\n\n\n\nTip\n\n\n\nFinding Your Working Directory from the console panel:\nRight next to your R version, you will see a file path starting with ~/.\nThis is your Working Directoryâ€”the specific folder on your computer where R is currently â€œlookingâ€ for files.\nThere is a small gray arrow next to the path in the Console. Clicking this will immediately refresh your Files pane (bottom-right) to show you exactly what is inside your working directory.\n\n\n\n\n\n\n\n\n\n0.2 Three Ways to Change Your Directory\nIf R is looking in the wrong place, you need to move it. You can do this interactively or through code.\n\nMethod A: The Script Tab (Interactive)\nIf you have a script saved in your project folder, right-click the Script Tab at the top of your editor and select â€œSet Working Directory.â€\n\n\n\n\n\n\n\nMethod B: The Files Pane (Interactive)\nIn the Files pane (bottom-right), navigate to the folder you want. Click the â€œMoreâ€ gear icon and select â€œSet As Working Directory.â€\n\n\n\n\n\n\n\nMethod C: Using Code (setwd())\nThis is the most direct way, but it requires typing out the path.\n\n\n\n0.3 Absolute vs.Â Relative Paths\nUnderstanding how R finds files is essential to avoiding the common \"File not found\" error.\n\n\n\n\n\n\n\n\nType\nDescription\nExample\n\n\nAbsolute Path\nThe full â€œGPS addressâ€ from the root drive.\nC:/Users/Name/Project/data/counts.csv\n\n\nRelative Path\nA shorthand address starting from your current folder.\ndata/counts.csv\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nBest Practice: Keep your data and your R script in the same folder (or a sub-folder) and use Relative Paths. This makes your project â€œportableâ€â€”it will work for anyone you share it with!\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWarning: Using setwd() is generally discouraged in shared projects because the path on your computer wonâ€™t exist on your colleagueâ€™s computer.\nWhy?\nBecause a path like C:/Users/Martina/... does not exist on your colleagueâ€™s computer. If you share your script, their R will crash immediately.\nBest Practice: Use R Projects (.Rproj). When you open an R Project, R automatically sets the working directory to that folder. This allows you to use Relative Paths, making your code â€œportableâ€ so it works for anyone, anywhere.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "ğŸ­ğŸ¬ Reading/Writing Data"
    ]
  },
  {
    "objectID": "WebsiteCodes/10RWData.html#writing-data-tables",
    "href": "WebsiteCodes/10RWData.html#writing-data-tables",
    "title": "Reading/Writing Data",
    "section": "1. Writing Data Tables",
    "text": "1. Writing Data Tables\nAfter cleaning or filtering your data, you need to save your results to your hard drive.\n\n1.1 Preparing the Demo Data\nWe will use the gapminder dataset to practice. We will create two subsets: one for Australia and one for the continent of Africa.\n\nif (!require(\"gapminder\", quietly = TRUE))\n    install.packages(\"gapminder\")\nlibrary(gapminder)\n\n\ndim(gapminder)\n## [1] 1704    6\n\nsummary(gapminder$lifeExp)\n##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n##   23.60   48.20   60.71   59.47   70.85   82.60\n\naust &lt;- gapminder[gapminder$country == \"Australia\",]\nafrica &lt;- gapminder[gapminder$continent == \"Africa\",]\n\n\n\n1.2 Saving as CSV with write.csv()\nThe Comma-Separated Value (.csv) is the universal language of data tables.\n\n# Create a 'data' folder in your current working directory\ndir.create(\"data\")\n\n# Save the Africa subset of the gapminder data\nwrite.csv(africa, file = \"data/gapminder_africa.csv\", row.names = FALSE)\n\n\n\n\n\n\n\nCaution\n\n\n\nThe â€œFolder Not Foundâ€ Error\nR is a great calculator, but it isnâ€™t a folder manager. If you tell R to save a file in a folder named data/ but that folder doesnâ€™t exist yet, R will throw an error: No such file or directory.\nBefore saving, you must create the folder manually or use this code:\n\n# Create a 'data' folder in your current working directory\ndir.create(\"data\")\n\n\n\n\n\n1.3 Saving as TSV with write.table()\nIn bioinformatics, Tab-Separated Value (.tsv) files are often preferred because gene names or clinical notes sometimes contain commas, which can â€œbreakâ€ a CSV file.\n\n# Saving as a TSV (using sep = \"\\t\")\nwrite.table(aust, file = \"data/gapminder_australia.tsv\", sep = \"\\t\", quote = FALSE, row.names = FALSE)\n\n\n\n\n\n\n\nNote\n\n\n\n\nsep = \"\\t\": Tells R to use a â€œTabâ€ to separate your values. Common ones are \",\" (comma), \"\\t\" (tab), and \"\" (white space).\nquote = FALSE: Prevents R from putting double quotes around every word, making the file much easier to read in a text editor.\n\n\n\n\n\n1.4 Exporting to Excel with write_xlsx()\nSometimes you need to share results with a collaborator who strictly uses Excel. The writexl package makes this easy.\n\nif (!require(\"writexl\", quietly = TRUE))\n    install.packages(\"writexl\")\nlibrary(writexl)\n\nwrite_xlsx(aust, path = \"data/gapminder_australia.xlsx\")\n\n\n\n1.5 Metadata and Versioning\nScientific data is iterative. You will likely generate 10 versions of the same table before your paper is published.\n\nThe â€œDatedâ€ Filename: Never name a file results_FINAL.csv. Instead, use: results_v1_2026-02-07.csv. When exporting data, always include a date or version number in the filename. This prevents overwriting and tells you exactly when the data was generated.\nThe row.names = FALSE Rule: By default, R tries to save the row numbers (1, 2, 3â€¦) into your file. This usually creates an annoying, unnamed â€œColumn 1â€ in Excel. Setting this to FALSE keeps your data clean.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "ğŸ­ğŸ¬ Reading/Writing Data"
    ]
  },
  {
    "objectID": "WebsiteCodes/10RWData.html#reading-data-tables",
    "href": "WebsiteCodes/10RWData.html#reading-data-tables",
    "title": "Reading/Writing Data",
    "section": "2. Reading Data Tables",
    "text": "2. Reading Data Tables\n\n2.1 Reading Text Files (.csv and .tsv)\n\n2.1.1 Base R\nThese functions come pre-installed with R. They are reliable and donâ€™t require any extra libraries, but can be slow with very large genomic datasets.\n\nread.csv() Specifically designed for CSV files. It automatically assumes that your data is separated by commas (,).\nread.table() (The â€œParentâ€ Function) This is the most flexible tool in your kit. While read.csv() is â€œlockedâ€ to commas, read.table() lets you specify any separator. This is essential for tab-separated genomic files.\n\n\ndataset &lt;- read.csv(\"data/gapminder_africa.csv\")\n\n\n# Reading a Tab-Separated file (.tsv or .txt)\ndataset &lt;- read.table(\"data/gapminder_australia.tsv\", \n                      header = TRUE,      # Does the first row have column names?\n                      sep = \"\\t\",         # What separates the data? (\\t = tab)\n                      stringsAsFactors = FALSE) # Keep text as text, not categories\n\n\n\n\n\n\n\nNoteKey Arguments for read.table:\n\n\n\n\nheader = TRUE: Tells R that the first line contains the names of the columns.\nsep: The character that separates your values. Common ones are \",\" (comma), \"\\t\" (tab), and \"\" (white space).\ndec: The character used for decimal points (useful if you are working with European data that uses a comma as a decimal).\n\n\n\n\n\n2.1.2 readr (Tidyverse)\nPart of the Tidyverse, read_csv() is faster and better at â€œguessingâ€ your data types correctly.\n\nif (!require(\"readr\", quietly = TRUE))\n    install.packages(\"readr\")\nlibrary(readr)\n\ndataset &lt;- read_csv(\"data/gapminder_africa.csv\")\n\n\n\n\n2.2 Reading from Excel (.xlsx)\nR cannot read Excel files natively. You need the readxl package.\n\nif (!require(\"readxl\", quietly = TRUE))\n    install.packages(\"readxl\")\nlibrary(readxl)\n\ndataset &lt;- read_excel(\"data/gapminder_australia.xlsx\", sheet = 1)\n\n\n\n2.3 The â€œPoint-and-Clickâ€ Method (Interactive)\nIf you are a beginner or canâ€™t remember the exact path to your file, use the Import Dataset button in the Environment panel (top-right).\n\nClick Import Dataset.\nBrowse your computer and select your file.\nLook at the â€œCode Previewâ€ box in the bottom-right of the window. RStudio writes the code for you! You should copy and paste that code into your script so that your work is reproducible next time.\n\n\n\n\n\n\n\nNote\n\n\n\nPerformance Limit:\nAvoid using the interactive importer for massive datasets (like 100MB+ genomic files). The â€œpreviewâ€ window will try to load the data to show it to you, which can cause RStudio to freeze.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "ğŸ­ğŸ¬ Reading/Writing Data"
    ]
  },
  {
    "objectID": "WebsiteCodes/10RWData.html#r-specific-formats-.rds-and-.rdata",
    "href": "WebsiteCodes/10RWData.html#r-specific-formats-.rds-and-.rdata",
    "title": "Reading/Writing Data",
    "section": "3. R-Specific Formats (.RDS and .RData)",
    "text": "3. R-Specific Formats (.RDS and .RData)\nSometimes you want to save an object exactly as it is in R (e.g., a complex statistical model or a large list).\n\n3.1 .RDS (Save one object)\nBest for saving a single dataframe or list. You can give it a new name when you load it back in.\n\nsaveRDS(africa, file = \"data/africa.RDS\")\n\nafrica_reloaded &lt;- readRDS(\"data/africa.RDS\")\n\n\n\n3.2 .RData (Save multiple objects)\nUsed to save your entire/some part of â€œEnvironment.â€ When you load it, the variables appear with their original names.\n\nsave(africa, aust, file = \"data/continents.RData\")\n\nload(\"data/continents.RData\", verbose = TRUE)\n\n\n\n3.3 Summary: RDS vs.Â RData vs.Â RProject\n\n\n\n\n\n\n\n\nFormat\nPurpose\nBest Use Case\n\n\n.RDS\nSaves one object.\nSaving a clean dataset to use in another script.\n\n\n.RData\nSaves multiple objects.\nSaving your whole workspace before lunch.\n\n\n.Rproj\nSaves settings/context.\nKeeping your file paths and open tabs organized.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "ğŸ­ğŸ¬ Reading/Writing Data"
    ]
  },
  {
    "objectID": "WebsiteCodes/12Packages4Data.html#the-base-r-struggle-a-scenario",
    "href": "WebsiteCodes/12Packages4Data.html#the-base-r-struggle-a-scenario",
    "title": "Advanced Data Manipulation",
    "section": "0. The â€œBase Râ€ Struggle (A Scenario)",
    "text": "0. The â€œBase Râ€ Struggle (A Scenario)\nImagine you have data from an experiment with a Control group and an Experimental group. Each group has 3 males and 3 females. You need to calculate the mean for each unique combination (Sex + Treatment).\nThe â€œOldâ€ Way (Base R): You have to manually subset the data for every single combination, creating new variables each time.\n\n# prepare demo dataset\nset.seed(228)\ndemo_data &lt;- data.frame(\n  \"Treatment\" = c(rep(\"ctrl\", 6), rep(\"experiment\", 6)),\n  \"Sex\" = c(rep(\"Male\", 3), rep(\"Female\", 3), rep(\"Male\", 3), rep(\"Female\", 3)),\n  \"Measurement\" = c(sample(100:300, 12))\n)\n\n# Calculating means manually\nCtrl_M &lt;- demo_data[which(demo_data$Treatment == \"ctrl\" & demo_data$Sex == \"Male\"), \"Measurement\"]\nmean(Ctrl_M)\n## [1] 213.3333\n\nCtrl_F &lt;- demo_data[which(demo_data$Treatment == \"ctrl\" & demo_data$Sex == \"Female\"), \"Measurement\"]\nmean(Ctrl_F)\n## [1] 149.3333\n\nNow imagine doing this for 10 treatments and 3 timepointsâ€¦ you would have 60 variables!\nThere are packages that provide functions to streamline common operations on tabular data and make the code look nicer and cleaner. These packages are part of a broader family called tidyverse, for more information you can visit https://www.tidyverse.org/.\nWe will cover 5 of the most commonly used functions and combine them using pipes (%&gt;%):\n1. select() - used to extract data\n2. filter() - to filter entries using logical vectors\n3. group_by() - to solve the split-apply-combine problem\n4. summarize() - to obtain summary statistics\n5. mutate() - to create new columns",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "ğŸ­ğŸ®\tAdvanced Data Manipulation"
    ]
  },
  {
    "objectID": "WebsiteCodes/12Packages4Data.html#the-tidyverse-philosophy",
    "href": "WebsiteCodes/12Packages4Data.html#the-tidyverse-philosophy",
    "title": "Advanced Data Manipulation",
    "section": "1. The tidyverse Philosophy",
    "text": "1. The tidyverse Philosophy\nTo solve this â€œvariable explosion,â€ we use dplyr. It is part of the tidyverse, a collection of R packages that are designed for data science and share a common grammar. The goal is to provide a consistent way to handle data frames. Instead of creating 60 intermediate objects, we create one Pipeline.\n\nif (!require(\"gapminder\", quietly = TRUE))\n    install.packages(\"gapminder\")\nlibrary(gapminder)\n\nif (!require(\"dplyr\", quietly = TRUE))\n    install.packages(\"dplyr\")\nlibrary(dplyr)\n\n\nThe Power of the Pipe (%&gt;%)\nThe pipe operator is the secret sauce of dplyr. It takes the output of one function and â€œpipesâ€ it directly into the next.\n\nThink of it as the word â€œTHENâ€.\n\n\nWhy use the pipe?\n\nReadability: Standard R code is nested like an onion: f(g(h(x))). You have to read from the inside out. With the pipe, you read from left to right (or top to bottom).\nNo â€œIntermediate Clutterâ€: You donâ€™t have to save temp_data_1, temp_data_2, etc.\nEasy Debugging: You can comment out one line of the pipe to see where the data â€œbreaks.â€\n\n\n\n\nComparisons: The Pipe vs.Â The Nest\nThe Nest (Hard to read):\n\n# Hard to tell which argument belongs to which function\nset.seed(228)\ndemo_data &lt;- data.frame(\n  \"Treatment\" = c(rep(\"ctrl\", 6), rep(\"experiment\", 6)),\n  \"Sex\" = c(rep(\"Male\", 3), rep(\"Female\", 3), rep(\"Male\", 3), rep(\"Female\", 3)),\n  \"Measurement\" = c(sample(100:300, 12))\n)\n\nas.data.frame(summarise(dplyr::group_by(demo_data, Treatment, Sex), Mean = mean(Measurement)))\n\n   Treatment    Sex     Mean\n1       ctrl Female 149.3333\n2       ctrl   Male 213.3333\n3 experiment Female 167.0000\n4 experiment   Male 136.0000\n\n\nThe Pipe (Easy to read):\n\n# Step-by-step logic\ndemo_data %&gt;% \n  dplyr::group_by(Treatment, Sex) %&gt;% \n  summarise(\n    Mean = mean(Measurement),\n    SD   = sd(Measurement),\n    .groups  = \"drop\"\n  ) %&gt;% \n  as.data.frame()\n\n   Treatment    Sex     Mean       SD\n1       ctrl Female 149.3333 11.06044\n2       ctrl   Male 213.3333 60.45108\n3 experiment Female 167.0000 19.46792\n4 experiment   Male 136.0000 24.75884\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nKeyboard Shortcut:\n\nWindows/Linux: Ctrl + Shift + M\nMac: Cmd + Shift + M\n\nFact: The pipe introduced in the magrittr package (2014) and popularized by dplyr (magrittr package was named after the artist RenÃ© Magritte, famous for the â€œThis is not a pipeâ€ painting).\nModern R: Since R 4.1.0, there is a built-in pipe |&gt;. It works similarly but has a few more restrictions (like requiring parentheses after every function).",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "ğŸ­ğŸ®\tAdvanced Data Manipulation"
    ]
  },
  {
    "objectID": "WebsiteCodes/12Packages4Data.html#the-core-dplyr-verbs",
    "href": "WebsiteCodes/12Packages4Data.html#the-core-dplyr-verbs",
    "title": "Advanced Data Manipulation",
    "section": "2. The Core dplyr Verbs",
    "text": "2. The Core dplyr Verbs\n\n2.1 select(): Picking Columns\nUse select() when you only want specific variables (columns) from your dataset. Think of it as a logical sieve: you define the criteria, and only the rows that meet those conditions pass through.\n\n# Select specific columns\ngapminder %&gt;% \n  dplyr::select(year, country, gdpPercap) %&gt;% \n  head()\n## # A tibble: 6 Ã— 3\n##    year country     gdpPercap\n##   &lt;int&gt; &lt;fct&gt;           &lt;dbl&gt;\n## 1  1952 Afghanistan      779.\n## 2  1957 Afghanistan      821.\n## 3  1962 Afghanistan      853.\n## 4  1967 Afghanistan      836.\n## 5  1972 Afghanistan      740.\n## 6  1977 Afghanistan      786.\n\n# Remove a column using the minus sign\ngapminder %&gt;% \n  dplyr::select(-continent) %&gt;% \n  head()\n## # A tibble: 6 Ã— 5\n##   country      year lifeExp      pop gdpPercap\n##   &lt;fct&gt;       &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n## 1 Afghanistan  1952    28.8  8425333      779.\n## 2 Afghanistan  1957    30.3  9240934      821.\n## 3 Afghanistan  1962    32.0 10267083      853.\n## 4 Afghanistan  1967    34.0 11537966      836.\n## 5 Afghanistan  1972    36.1 13079460      740.\n## 6 Afghanistan  1977    38.4 14880372      786.\n\n\n\n\n\n\n\nNote\n\n\n\nAnother way of coding:\n\ndplyr::select(.data = gapminder, \n              year, country, gdpPercap) %&gt;%\n  head()\n\n# A tibble: 6 Ã— 3\n   year country     gdpPercap\n  &lt;int&gt; &lt;fct&gt;           &lt;dbl&gt;\n1  1952 Afghanistan      779.\n2  1957 Afghanistan      821.\n3  1962 Afghanistan      853.\n4  1967 Afghanistan      836.\n5  1972 Afghanistan      740.\n6  1977 Afghanistan      786.\n\ndplyr::select(.data = gapminder,\n              -continent) %&gt;%\n  head()\n\n# A tibble: 6 Ã— 5\n  country      year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan  1952    28.8  8425333      779.\n2 Afghanistan  1957    30.3  9240934      821.\n3 Afghanistan  1962    32.0 10267083      853.\n4 Afghanistan  1967    34.0 11537966      836.\n5 Afghanistan  1972    36.1 13079460      740.\n6 Afghanistan  1977    38.4 14880372      786.\n\n\n\n\n\n\n2.2 filter(): Picking Rows\nUse filter() to find observations (rows) that meet a certain condition.\n\n# Include only European countries in the year 2007\ngapminder %&gt;% \n  dplyr::filter(continent == \"Europe\", year == 2007) %&gt;% \n  dplyr::select(country, lifeExp)\n## # A tibble: 30 Ã— 2\n##    country                lifeExp\n##    &lt;fct&gt;                    &lt;dbl&gt;\n##  1 Albania                   76.4\n##  2 Austria                   79.8\n##  3 Belgium                   79.4\n##  4 Bosnia and Herzegovina    74.9\n##  5 Bulgaria                  73.0\n##  6 Croatia                   75.7\n##  7 Czech Republic            76.5\n##  8 Denmark                   78.3\n##  9 Finland                   79.3\n## 10 France                    80.7\n## # â„¹ 20 more rows\n\n\n\n\n\n\n\nNote\n\n\n\nThe Base R Way\nThe logic is â€œnested.â€ You have to read from the inside out to understand what is happening, and you must repeat the name of the data frame (gapminder$) multiple times.\n\ngapminder[which(gapminder$continent == \"Europe\" & gapminder$year == 2007), \n          c(\"country\", \"lifeExp\")]\n## # A tibble: 30 Ã— 2\n##    country                lifeExp\n##    &lt;fct&gt;                    &lt;dbl&gt;\n##  1 Albania                   76.4\n##  2 Austria                   79.8\n##  3 Belgium                   79.4\n##  4 Bosnia and Herzegovina    74.9\n##  5 Bulgaria                  73.0\n##  6 Croatia                   75.7\n##  7 Czech Republic            76.5\n##  8 Denmark                   78.3\n##  9 Finland                   79.3\n## 10 France                    80.7\n## # â„¹ 20 more rows",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "ğŸ­ğŸ®\tAdvanced Data Manipulation"
    ]
  },
  {
    "objectID": "WebsiteCodes/12Packages4Data.html#the-power-duo-group_by-and-summarize",
    "href": "WebsiteCodes/12Packages4Data.html#the-power-duo-group_by-and-summarize",
    "title": "Advanced Data Manipulation",
    "section": "3. The Power Duo: group_by() and summarize()",
    "text": "3. The Power Duo: group_by() and summarize()\nThis is the most common workflow in bioinformatics. You split the data into groups, apply a calculation, and combine the results into a summary table.\n\n3.1 group_by()\nThis doesnâ€™t change the data visually; it creates â€œhiddenâ€ groups that R remembers for the next step.\n\n\n\n\n\n\ngapminder %&gt;% \n  dplyr::group_by(continent)\n## # A tibble: 1,704 Ã— 6\n## # Groups:   continent [5]\n##    country     continent  year lifeExp      pop gdpPercap\n##    &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n##  1 Afghanistan Asia       1952    28.8  8425333      779.\n##  2 Afghanistan Asia       1957    30.3  9240934      821.\n##  3 Afghanistan Asia       1962    32.0 10267083      853.\n##  4 Afghanistan Asia       1967    34.0 11537966      836.\n##  5 Afghanistan Asia       1972    36.1 13079460      740.\n##  6 Afghanistan Asia       1977    38.4 14880372      786.\n##  7 Afghanistan Asia       1982    39.9 12881816      978.\n##  8 Afghanistan Asia       1987    40.8 13867957      852.\n##  9 Afghanistan Asia       1992    41.7 16317921      649.\n## 10 Afghanistan Asia       1997    41.8 22227415      635.\n## # â„¹ 1,694 more rows\n\n\n\n3.2 summarize()\nThis â€œcollapsesâ€ each group into a single row of statistics.\n\n\n\n\n\n\n# Calculate mean GDP and Standard Error for each continent\ngapminder %&gt;% \n  dplyr::group_by(continent) %&gt;% \n  dplyr::summarize(\n    mean_le = mean(lifeExp),\n    min_le = min(lifeExp),\n    max_le = max(lifeExp),\n    se_le = sd(lifeExp) / sqrt(dplyr::n()) # n() counts the number of observations\n  )\n## # A tibble: 5 Ã— 5\n##   continent mean_le min_le max_le se_le\n##   &lt;fct&gt;       &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;\n## 1 Africa       48.9   23.6   76.4 0.366\n## 2 Americas     64.7   37.6   80.7 0.540\n## 3 Asia         60.1   28.8   82.6 0.596\n## 4 Europe       71.9   43.6   81.8 0.286\n## 5 Oceania      74.3   69.1   81.2 0.775",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "ğŸ­ğŸ®\tAdvanced Data Manipulation"
    ]
  },
  {
    "objectID": "WebsiteCodes/12Packages4Data.html#mutate-creating-new-variables",
    "href": "WebsiteCodes/12Packages4Data.html#mutate-creating-new-variables",
    "title": "Advanced Data Manipulation",
    "section": "4. mutate(): Creating New Variables",
    "text": "4. mutate(): Creating New Variables\nmutate() allows you to add new columns while keeping the old ones. It is perfect for calculations like unit conversions or normalization.\n\n# Create a new column for GDP in billions\ngapminder %&gt;% \n  dplyr::mutate(gdp_billion = gdpPercap * pop / 10^9) %&gt;% \n  head()\n## # A tibble: 6 Ã— 7\n##   country     continent  year lifeExp      pop gdpPercap gdp_billion\n##   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n## 1 Afghanistan Asia       1952    28.8  8425333      779.        6.57\n## 2 Afghanistan Asia       1957    30.3  9240934      821.        7.59\n## 3 Afghanistan Asia       1962    32.0 10267083      853.        8.76\n## 4 Afghanistan Asia       1967    34.0 11537966      836.        9.65\n## 5 Afghanistan Asia       1972    36.1 13079460      740.        9.68\n## 6 Afghanistan Asia       1977    38.4 14880372      786.       11.7",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "ğŸ­ğŸ®\tAdvanced Data Manipulation"
    ]
  },
  {
    "objectID": "WebsiteCodes/12Packages4Data.html#putting-it-all-together",
    "href": "WebsiteCodes/12Packages4Data.html#putting-it-all-together",
    "title": "Advanced Data Manipulation",
    "section": "5. Putting It All Together",
    "text": "5. Putting It All Together\nThe true beauty of dplyr is chaining everything into one clean pipeline.\n\n# A complete pipeline: Create a variable, group it, and summarize it\nsummary_table &lt;- gapminder %&gt;% \n  dplyr::mutate(gdp_billion = gdpPercap * pop / 10^9) %&gt;% \n  dplyr::group_by(continent, year) %&gt;% \n  dplyr::summarize(\n    mean_gdpPercap = mean(gdpPercap),\n    sd_gdpPercap = sd(gdpPercap),\n    mean_pop = mean(pop),\n    sd_pop = sd(pop),\n    mean_gdp_billion = mean(gdp_billion),\n    sd_gdp_billion = sd(gdp_billion)\n  )\n\nhead(summary_table)\n## # A tibble: 6 Ã— 8\n## # Groups:   continent [1]\n##   continent  year mean_gdpPercap sd_gdpPercap mean_pop   sd_pop mean_gdp_billion\n##   &lt;fct&gt;     &lt;int&gt;          &lt;dbl&gt;        &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;            &lt;dbl&gt;\n## 1 Africa     1952          1253.         983. 4570010.   6.32e6             5.99\n## 2 Africa     1957          1385.        1135. 5093033.   7.08e6             7.36\n## 3 Africa     1962          1598.        1462. 5702247.   7.96e6             8.78\n## 4 Africa     1967          2050.        2848. 6447875.   8.99e6            11.4 \n## 5 Africa     1972          2340.        3287. 7305376.   1.01e7            15.1 \n## 6 Africa     1977          2586.        4142. 8328097.   1.16e7            18.7 \n## # â„¹ 1 more variable: sd_gdp_billion &lt;dbl&gt;\n\n\n\n\n\n\n\nNoteWhy use dplyr::?\n\n\n\nYouâ€™ll notice I used dplyr::select() instead of just select(). As we discussed in the â€œFunctionsâ€ module, many packages have a filter or select function. Being explicit ensures that your code never breaks, even if you load other libraries later.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Data Manipulation",
      "ğŸ­ğŸ®\tAdvanced Data Manipulation"
    ]
  },
  {
    "objectID": "WebsiteCodes/14Software.html#good-coding-practices",
    "href": "WebsiteCodes/14Software.html#good-coding-practices",
    "title": "Software Development Concepts",
    "section": "1. Good Coding Practices",
    "text": "1. Good Coding Practices\n\n1.1 Script Structure\nA script should read like a story. Organize it so a colleague (or â€œFuture Youâ€) can understand the setup before the action.\n\nSectioning: Use comments (e.g., #### SECTION NAME ####) to create a map of your script.\n\nFolding: You can click the small triangle icon next to the line numbers to â€œfoldâ€ (hide) a big chunk of code once you are finished with it. This keeps your workspace tidy.\nNavigation: In RStudio, you can click the Outline icon (top right of the script window) to see a table of contents. Click any section name to jump straight to that code.\nThe Shortcut: Use Cmd + Shift + R (Mac) or Ctrl + Shift + R (Windows) to instantly insert a new section header.\n\nThe â€œHeadâ€ of the Script:\nAlways load your libraries and set your environment variables (like set.seed()) at the very top. This acts as a â€œRequired Hardwareâ€ list for R. If someone else tries to run your code, they will know immediately which packages they need to install.\nFunction Management:\nKeep your main analysis clean. If you have many custom functions:\n\nThe â€œFunctionsâ€ Section: Put them in a dedicated section right below your library imports.\nThe External File: For very long scripts, save your functions in a separate file (e.g., utils.R) and bring them in using source(\"utils.R\").\n\n\n\nAnatomy of a Professional Script\nHere is a template demonstrating a clean, professional structure:\n\n# 0. Setup -----------------------------------------------------------------\n\n## Data Explanation:\n# This script analyzes the progranulin (GRN) expression in scRNA-seq data.\n# Last updated: Feb 2026 by [Your Name] [Finsihed Data Pre-processing]\n\n# Load Libraries\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# Global Settings\nset.seed(228) # Ensures reproducibility for random samplings\n\n# Customized Functions\nCalculateFoldChange &lt;- function(x, y) { return(log2(x/y)) }\n\n# 1. Load Data -------------------------------------------------------------\n# raw_counts &lt;- read.csv(\"data/counts.csv\")\n\n# 2. Pre-processing --------------------------------------------------------\n\n# 3. Statistical Analysis --------------------------------------------------\n\n\n\n\n1.2 Writing Robust Functions\nIn bioinformatics, naming and documentation are vital to avoid mixing up your genomic variables.\n\nNaming Conventions (PascalCase)\nUse PascalCase (Capitalizing each word) for functions to distinguish them from standard R variables.\n\n# Good: Stands out as a custom tool\nCalculateFoldChange &lt;- function(ctrl, exp) { ... }\n\n# Bad: Looks like a generic variable\nfoldchange &lt;- function(ctrl, exp) { ... }\n\n\n\nExplicit Returns\nWhile R automatically returns the last line, being explicit makes your code safer and easier to debug.\n\n# Good: Explicitly states what is being handed back\nAddValues &lt;- function(x, y) {\n  return(x + y)\n}\n\n\n\nInternal Documentation\nAlways include a â€œReceiptâ€ at the top of your function explaining what it needs and what it gives back.\n\nAddValues &lt;- function(x, y) {\n  # Description: Adds two numeric values for gene expression normalization\n  # Input: x (numeric), y (numeric)\n  # Output: numeric sum\n  \n  return(x + y)\n}\n\n\n\n\n1.3 Documentation and Testing\nAs your McGill research projects grow into potential publications, you may want to use professional tools:\n\nroxygen2: Allows you to write â€œHelp Filesâ€ (like the ones you see when typing ?sum) directly in your script.\ntestthat: A framework for â€œUnit Testing.â€ It automatically checks if your functions still work correctly after you make changes to your code.\n\n\n\n1.4 External Packages & Namespacing\nLoading a library is like opening a whole toolbox. If you only need one hammer, donâ€™t bring the whole box.\n\nThe â€œRule of Twoâ€: If you only use 1 or 2 functions from a package, donâ€™t use library(). Use the Namespaceinstead.\nNamespacing: This prevents â€œFunction Maskingâ€ (when two packages have a function with the same name).\n\n\n# Good: Explicit and avoids conflicts\npurrr::map()\n\n# Bad: Might conflict with 'map' from the 'maps' package\nmap()",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Generating Visual Outputs",
      "ğŸ­ğŸ° Software Development Concepts"
    ]
  },
  {
    "objectID": "WebsiteCodes/14Software.html#debugging-and-troubleshooting",
    "href": "WebsiteCodes/14Software.html#debugging-and-troubleshooting",
    "title": "Software Development Concepts",
    "section": "2. Debugging and Troubleshooting",
    "text": "2. Debugging and Troubleshooting\nEvery bioinformatician gets errors. The difference between a beginner and a pro is how they react to them.\n\nThe â€œMinimal Reproducible Exampleâ€ (Reprex): Try to recreate the error using a tiny, fake dataset (like df &lt;- data.frame(a=1:5)). If the error disappears, the problem is with your data. If the error stays, the problem is with your logic.\nThe â€œGoogleâ€ Rule: Copy the last line of the error message.\n\n\n\n\n\n\nTip\n\n\n\nIf the error involves a specific package, include the package name in your search (e.g., \"Error in .External2() unable to start data viewer ggplot2\").\n\n\nCheck the â€œStateâ€: Use sessionInfo() to see if your package versions are causing the conflict.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Generating Visual Outputs",
      "ğŸ­ğŸ° Software Development Concepts"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise1.html#atomic-classes",
    "href": "WebsiteCodes/Exercise1.html#atomic-classes",
    "title": "Hands-on Exercise: Data Types",
    "section": "1. Atomic Classes",
    "text": "1. Atomic Classes\n\nWrite a piece of code that stores a number in a variable and then check if it is greater than 5. Try to use comments!\nBonus: Is there a way to store the result after checking the number?\n\n\n# 1.  Write a piece of code that stores a number in a variable and then check if it is greater than 5. Try to use comments!\n\n# 2.  Bonus: Is there a way to store the result after checking the number?",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼‘"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise1.html#vectors",
    "href": "WebsiteCodes/Exercise1.html#vectors",
    "title": "Hands-on Exercise: Data Types",
    "section": "2. Vectors",
    "text": "2. Vectors\nMake a vector with the numbers 1 through 26. Multiply the vector by 2, and give the resulting vector names A through Z (hint: there is a built in vector called LETTERS).\n\n# Make a vector with the numbers 1 through 26. Multiply the vector by 2, and give the resulting vector names A through Z (hint: there is a built in vector called LETTERS).",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼‘"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise1.html#matrices",
    "href": "WebsiteCodes/Exercise1.html#matrices",
    "title": "Hands-on Exercise: Data Types",
    "section": "3. Matrices",
    "text": "3. Matrices\nMake a matrix with the numbers 1:50, with 5 columns and 10 rows. Did the matrix function fill your matrix by column, or by row, as its default behavior? Once you have figured it out, try to change the default. (hint: read the documentation for matrix)\n\n# Make a matrix with the numbers 1:50, with 5 columns and 10 rows. Did the matrix function fill your matrix by column, or by row, as its default behavior? Once you have figured it out, try to change the default. (hint: read the documentation for `matrix`)\n\nBonus: Which of the following commands was used to generate the matrix below?\n\n\n\n\n[,1]\n[,2]\n\n\n[1,]\n4\n1\n\n\n[2,]\n9\n5\n\n\n[3,]\n10\n7\n\n\n\n\nmatrix(c(4, 1, 9, 5, 10, 7), nrow = 3)\nmatrix(c(4, 9, 10, 1, 5, 7), ncol = 2, byrow = TRUE)\nmatrix(c(4, 9, 10, 1, 5, 7), nrow = 2)\nmatrix(c(4, 1, 9, 5, 10, 7), ncol = 2, byrow = TRUE)\n\n\n# Bonus: Which of the following commands was used to generate the matrix below?",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼‘"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise1.html#lists",
    "href": "WebsiteCodes/Exercise1.html#lists",
    "title": "Hands-on Exercise: Data Types",
    "section": "4. Lists",
    "text": "4. Lists\nCreate a list of length two containing a character vector for each of the data sections: (1) Data types and (2) Data structures. Populate each character vector with the names of the data types and data structures, respectively.\n\n# Create a list of length two containing a character vector for each of the data sections: (1) Data types and (2) Data structures. Populate each character vector with the names of the data types and data structures, respectively.",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼‘"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise1.html#data-frames",
    "href": "WebsiteCodes/Exercise1.html#data-frames",
    "title": "Hands-on Exercise: Data Types",
    "section": "5. Data frames",
    "text": "5. Data frames\nThere are several subtly different ways to call variables, observations and elements from data frames. Try them all and discuss with your team what they return. (Hint, use the function typeof())\n\niris[1]\niris[[1]]\niris$Species\niris[\"Species\"]\niris[1,1]\niris[,1]\niris[1,]\n\n\n# There are several subtly different ways to call variables, observations and elements from data frames. Try them all and discuss with your team what they return. (Hint, use the function typeof())",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼‘"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise1.html#coercion",
    "href": "WebsiteCodes/Exercise1.html#coercion",
    "title": "Hands-on Exercise: Data Types",
    "section": "6. Coercion",
    "text": "6. Coercion\nTake the list you created in 4 and coerce it into a data frame. Then change the names of the columns to â€œdataTypesâ€ and â€œdataStructuresâ€\n\n# Take the list you created in 4 and coerce it into a data frame. Then change the names of the columns to \"dataTypes\" and \"dataStructures\"",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼‘"
    ]
  },
  {
    "objectID": "WebsiteCodes/Exercise3.html",
    "href": "WebsiteCodes/Exercise3.html",
    "title": "Hands-on Exercise: Advance Data Manipulation",
    "section": "",
    "text": "suppressPackageStartupMessages(library(gapminder))\nsuppressPackageStartupMessages(library(dplyr))\n\nWrite one command ( can span multiple lines) using pipes that will output a data frame that has only the columns lifeExp, country and year for the records before the year 2000 from African countries, but not for other Continents.\nCalculate the average life expectancy per country. Which country has the longest average life expectancy and which one the shortest average life expectancy?\nIn the previous hands-on you discovered that all the entries from 2007 are actually from 2008. Write a command to edit the data accordingly using pipes. In the same command filter only the entries from 2008 to verify the change.",
    "crumbs": [
      "ğŸƒï¼¥ï¼¸ï¼¥ï¼²ï¼£ï¼©ï¼³ï¼¥ï¼ƒï¼“"
    ]
  },
  {
    "objectID": "WebsiteCodes/MaterialsInstructions.html#how-code-is-demonstrated",
    "href": "WebsiteCodes/MaterialsInstructions.html#how-code-is-demonstrated",
    "title": "How to Use These Materials",
    "section": "How Code is Demonstrated",
    "text": "How Code is Demonstrated\nThroughout these materials, we use live-rendered code blocks to demonstrate Râ€™s functionality. This means the results you see on the website were generated by the code right above them.\n\n\n\n\n\n\nThe Code Block\nYou will see code blocks with a copy button in the top-right corner.\n\nTo try it yourself: Click copy and paste the code into your RStudio Source Editor or Console.\nTo run it: Use the shortcuts Cmd + Return (Mac) or Ctrl + Enter (Windows).\nIf you need a refresher on running code, refer to Get Acquainted with R and RStudio Section - 3.2.4: Executing Code.\n\n\n\nThe Output\nImmediately following the code block, you will see the results. These lines represent the exact output you will see in your RStudio Console on your own computer.",
    "crumbs": [
      "How to Use This Materials"
    ]
  },
  {
    "objectID": "WebsiteCodes/MaterialsInstructions.html#how-the-workshop-is-structured",
    "href": "WebsiteCodes/MaterialsInstructions.html#how-the-workshop-is-structured",
    "title": "How to Use These Materials",
    "section": "How the Workshop is Structured",
    "text": "How the Workshop is Structured\nWe follow a â€œWalk-through and Practiceâ€ model:\n\nInteractive Review: We will first go through the online materials together to establish the core concepts.\nHands-on Session: We will then transition to RStudio on your individual computers to practice coding in real-time.\n\nThe code on this website serves as a reference guide, but the real learning happens when you type and troubleshoot on your own machine.",
    "crumbs": [
      "How to Use This Materials"
    ]
  },
  {
    "objectID": "WebsiteCodes/MaterialsInstructions.html#why-a-website-instead-of-slides",
    "href": "WebsiteCodes/MaterialsInstructions.html#why-a-website-instead-of-slides",
    "title": "How to Use These Materials",
    "section": "Why a Website Instead of Slides?",
    "text": "Why a Website Instead of Slides?\nTraditional slides can often be a barrier to learning code for a few reasons:\n\nThe â€œSetupâ€ Lag: In many workshops, significant time is lost waiting for everyone to reach the same setup step, causing faster students to lose momentum.\nInformation Density: Long, dense slides can be distracting. It is easy to lose your place, and once you fall behind, it is difficult to catch up.\nSelf-Paced Learning: As someone who values clear, manageable steps, I designed this format to be beginner-friendly. You can stop, re-read, and continue at any time.\n\nThis website is intended to be a living resourceâ€”something you can study at your own pace during the workshop and return to for review later in your research.",
    "crumbs": [
      "How to Use This Materials"
    ]
  },
  {
    "objectID": "WebsiteCodes/MaterialsInstructions.html#behind-the-scenes-how-this-site-was-built",
    "href": "WebsiteCodes/MaterialsInstructions.html#behind-the-scenes-how-this-site-was-built",
    "title": "How to Use These Materials",
    "section": "Behind the Scenes: How this Site was Built",
    "text": "Behind the Scenes: How this Site was Built\nThis site is built using Quarto and Markdown, hosted via GitHub Pages.\nMarkdown is a lightweight text-editing language that is excellent for combining professional page layouts with live code. Much like LaTeX, it is a powerful tool for academic writing, and learning it will help you in your own research documentation!",
    "crumbs": [
      "How to Use This Materials"
    ]
  },
  {
    "objectID": "WebsiteCodes/Overview2.html",
    "href": "WebsiteCodes/Overview2.html",
    "title": "Overview: Control Structures & Functions",
    "section": "",
    "text": "Learning Objectives\n\nMaster if statements: Teach your code how to make decisions.\nUnderstand for & while loops: Automate repetitive tasks over thousands of genes or samples.\nCreate Custom Functions: Write your own reusable tools to keep your scripts clean.\nInstall & Manage Packages: Unlock the power of the R community by installing specialized bioinformatics libraries.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Control Structures and Functions",
      "Overview"
    ]
  },
  {
    "objectID": "WebsiteCodes/Overview4.html#generating-visual-outputs",
    "href": "WebsiteCodes/Overview4.html#generating-visual-outputs",
    "title": "Overview: Generating Visual Outputs",
    "section": "Generating Visual Outputs",
    "text": "Generating Visual Outputs\nBy the end of this module, you will be able to:\n\nConstruct Base R Graphics: Quickly generate exploratory plots using foundational functions like plot(), hist(), and boxplot().\nMaster the Grammar of Graphics: Understand the ggplot2 philosophyâ€”how to map data variables to visual aesthetics (colors, shapes, and axes).\nBuild Layered Visualizations: Create professional-grade scatter plots, bar charts, and line graphs by layering geometric objects (geoms).\nLeverage Factors for Design: Use factor levels to control the order, grouping, and color-coding of categorical data in your plots.\nAutomate Reporting: Use RMarkdown (or Quarto) to weave together code, results, and narrative text into polished, reproducible PDF or HTML reports.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Generating Visual Outputs",
      "Overview"
    ]
  },
  {
    "objectID": "WebsiteCodes/Overview4.html#software-development-concepts",
    "href": "WebsiteCodes/Overview4.html#software-development-concepts",
    "title": "Overview: Generating Visual Outputs",
    "section": "Software Development Concepts",
    "text": "Software Development Concepts\nBy the end of this module, you will be able to:\n\nImplement Best Practices: Write clean, readable code using consistent naming conventions and logical script structures.\nStandardize Documentation: Use comments and headers to document your logic, ensuring your analysis is understandable to â€œFuture Youâ€ and your collaborators.\nAvoid Common Pitfalls: Identify and steer clear of frequent R â€œanti-patterns,â€ such as mixing up = and == or failing to manage working directories.\nTroubleshoot and Debug: Develop a systematic approach to reading error messages, using the RStudio debugger, and finding solutions in the R community.",
    "crumbs": [
      "ğ‘ ğğ€ğ’ğˆğ‚ğ’: Generating Visual Outputs",
      "Overview"
    ]
  },
  {
    "objectID": "WebsiteCodes/RStudio.html",
    "href": "WebsiteCodes/RStudio.html",
    "title": "Get Acquainted with R and RStudio",
    "section": "",
    "text": "By the end of this page, you will understand:\n\nThe distinction between R and RStudio (the â€œEngineâ€ vs.Â the â€œDashboardâ€).",
    "crumbs": [
      "Get Acquainted with R and RStudio"
    ]
  },
  {
    "objectID": "WebsiteCodes/RStudio.html#learning-objectives",
    "href": "WebsiteCodes/RStudio.html#learning-objectives",
    "title": "Get Acquainted with R and RStudio",
    "section": "",
    "text": "By the end of this page, you will understand:\n\nThe distinction between R and RStudio (the â€œEngineâ€ vs.Â the â€œDashboardâ€).",
    "crumbs": [
      "Get Acquainted with R and RStudio"
    ]
  },
  {
    "objectID": "WebsiteCodes/RStudio.html#r-vs.-rstudio-the-engine-and-the-dashboard",
    "href": "WebsiteCodes/RStudio.html#r-vs.-rstudio-the-engine-and-the-dashboard",
    "title": "Get Acquainted with R and RStudio",
    "section": "1. R vs.Â RStudio: The Engine and the Dashboard",
    "text": "1. R vs.Â RStudio: The Engine and the Dashboard\nIt is common to get these confused, but they are separate entities:\n\nR (The Engine): The programming language that does the actual math. It was developed at the University of Auckland.\n\nIt is the powerful machine under the hood. It does all the heavy lifting, makes the car move, and handles the energy. But on its own, an engine is just a block of metal on the floorâ€”you canâ€™t sit in it or steer it easily.\n\n\n\n\n\n\nRStudio (The Dashboard): An Integrated Development Environment (IDE). It is the software interface (developed by Posit) that makes writing R code much easier.\n\nItâ€™s the steering wheel, the seats, the GPS, and the speedometer. Itâ€™s the beautiful interface that lets you interact with the engine so you can actually drive where you want to go.\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nKey Takeaway: Each program must be downloaded separately. You need to install both programs on your computer, but you will only ever â€œopenâ€ RStudio to do your work.",
    "crumbs": [
      "Get Acquainted with R and RStudio"
    ]
  },
  {
    "objectID": "WebsiteCodes/RStudio.html#file-types-scripts-vs.-notebooks",
    "href": "WebsiteCodes/RStudio.html#file-types-scripts-vs.-notebooks",
    "title": "Get Acquainted with R and RStudio",
    "section": "2. File Types: Scripts vs.Â Notebooks",
    "text": "2. File Types: Scripts vs.Â Notebooks\nIn R, there are several ways to save your work. Choosing the right file type depends on whether you are writing code for a â€œcomputerâ€ to run or a â€œhumanâ€ to read.\n\n\n\nDemo of R Scripts (.R)\n\n\n\n\n\n\nDemo of Notebooks (.Rmd, .qmd, .ipynb)\n\n\n\n\n\n2.1 R Scripts (.R)\nThink of an R Script like a plain text file for code.\n\nBest for: Automation, data cleaning pipelines, and long-term â€œheavy lifting.â€\nPros: Very fast and lightweight. It is the â€œgold standardâ€ for portability because it doesnâ€™t require any special software other than R itself to run.\nCons: Not great for storytelling; you can add comments (using #), but you canâ€™t include formatted text, headers, or images easily.\n\n\n\n2.2 Notebooks (.Rmd, .qmd, .ipynb)\nNotebooks follow the â€œLiterate Programmingâ€ philosophy, where your code, its output (plots/tables), and your narrative text live together in one document.\n\nR Markdown (.Rmd): The classic notebook for R. It has been the industry standard for years for creating PDFs and Word reports.\nQuarto (.qmd): The modern â€œsuccessorâ€ to R Markdown. It is more powerful and supports multiple languages (R, Python, Julia). This entire website was built using Quarto!\nJupyter Notebook (.ipynb): Most common in the Python community, but can be used for R. Great for interactive data exploration but harder to use for writing a full thesis or book.\n\n\n\n2.3 Comparison at a Glance\n\n\n\n\n\n\n\n\n\nFile Type\nExtension\nPrimary Use Case\nBest Analogy\n\n\n\n\nR Script\n.R\nPure code. Building tools and automating data cleaning.\nA Recipe Card: Just the instructions.\n\n\nNotebook\n.qmd / .Rmd\nWriting reports, theses, or sharing results with a PI.\nA Lab Notebook: The instructions + the results + your thoughts.\n\n\n\n\n\n2.4 Which one should I use?\n\nIf you are writing a script that will run on a server overnight to process data: Use an R Script (.R).\nIf you are analyzing your results and want to show your PI a visualization along with your interpretation: Use Quarto (.qmd) or R Markdown (.Rmd).",
    "crumbs": [
      "Get Acquainted with R and RStudio"
    ]
  },
  {
    "objectID": "WebsiteCodes/RStudio.html#how-to-interact-with-rstudio",
    "href": "WebsiteCodes/RStudio.html#how-to-interact-with-rstudio",
    "title": "Get Acquainted with R and RStudio",
    "section": "3. How to interact with RStudio",
    "text": "3. How to interact with RStudio\n\n\n\n\n\n\nNote\n\n\n\nWelcome to your new workspace!\nIs this your first time opening RStudio? The interface can feel overwhelming at first with its four different panes. Donâ€™t worryâ€”each one has a specific purpose designed to keep your research organized.\n\n\n\n3.1 Overview\nAs shown in the figure below, the RStudio interface is divided into four primary panes. By default, they are arranged and named as follows:\n\nSource Editor (Top-Left): Where you write and save your code.\nConsole (Bottom-Left): Where R executes your commands and shows immediate results.\nEnvironment & History (Top-Right): Where your active data and past commands are stored.\nFiles, Plots, & Help (Bottom-Right): Your utility pane for navigating files, viewing graphs, and reading documentation.\n\n\n\n\n\n\n\n\n\n\n\n\nTipWhat to do if a pane is missing\n\n\n\nIf your screen doesnâ€™t look like the default layout, or if one of the panes has disappeared:\n\nGo to the top menu and select View &gt; Panes &gt; Show All Panes.\nYou can further customize the layout and appearance under this same menu to suit your personal preferences.\n\n\n\n\n\n\n\n\n\nTipThe â€œDisappearingâ€ Source Pane\n\n\n\nA common question from beginners is: â€œWhy do I only see three windows?â€ If the Source Editor (the top-left window) is missing, it is usually because you havenâ€™t opened a file yet.\nTo make it appear, you simply need to create a new script:\n\nVia Menu: Select File &gt; New File &gt; R Script.\nVia Keyboard Shortcut:\n\nPC: Ctrl + Shift + N\nMac: Cmd + Shift + N\n\n\n\n\n\n\n3.2 The Source Editor (Top-Left)\nThis is your primary workspace. Think of it as a specialized â€œText Editorâ€ for your research files.\n\n\n\n\n\n\n3.2.1 Function Overview\nYou use this pane to write, edit, and save your scripts. Unlike the Console, everything you type here can be saved for future use.\n\n\n3.2.2 Compatibility\nRStudio can open almost any text-based file, including:\n\nData Scripts: R (.R), Python (.py), or SQL.\nNotebooks: Quarto (.qmd) and R Markdown (.Rmd).\nDocuments: Plain text (.txt), LaTeX (.tex), and BibTeX (.bib).\n\n\n\n3.2.3 Data Viewer\nYou can also use this pane to inspect datasets in a â€œread-onlyâ€ spreadsheet format (similar to Excel).\n\n\n3.2.4 Executing Code\nTo run code from the Source Editor, you donâ€™t just hit â€œEnter.â€ Instead, you use a specific keyboard shortcut to â€œsendâ€ the code from your script down to the Console:\n\nMac: Cmd + Return (or Enter)\nWindows/Linux: Ctrl + Enter\nNote: If you hit Enter by itself in the Source Editor, it will simply create a new lineâ€”just like in a Word document. It will not run your code.\n\n\n\n\n\n\n\nNoteWays to Run Your Code\n\n\n\n\nRun a Single Line: Place your cursor anywhere on the line you want to execute and use the shortcut.\nRun a Section: Highlight a block of code with your mouse and then use the shortcut to run the entire selection at once.\nThe â€œRunâ€ Button: You can also highlight your code and click the Run button in the top-right corner of the Source Pane. However, most professional R users prefer the keyboard shortcuts as they are much faster and more efficient!\n\n\n\n\n\n3.2.5 Limitation\nYou cannot open Microsoft Office documents (.docx, .xlsx) or image files directly hereâ€”those must be imported using code.\n\n\n\n3.3 The Console (Bottom-Left)\nThe Console is the â€œEngine Room.â€ This is where R actually executes your commands and displays the results.\n\n\n\n\n\n\nExecuting Code: You can type code directly into the Console and hit Enter/Return to see the result immediately.\n\nThe Drawback: You cannot easily edit a command once it has been run. While you can use the Up Arrow key to retrieve your previous lines, these commands are not saved to your file.\nBest Practice: Always write your code in a Script (Source Pane) first, then â€œsendâ€ it to the Console to run. This ensures your work is reproducible.\nIt is worth emphasizing again: Code typed directly into the Console is not saved. If you want to keep your work, always write your code in the Source Editor and â€œsendâ€ it to the Console to run.\nHow to rescue â€œlostâ€ code: If you accidentally ran a long line of code in the Console and realized you forgot to save it to your script, donâ€™t worry! You can find it in the History tab (Top-Right pane).\n\nThe History tab shows every command you have executed in order.\nIt does not show the results or outputs (like plots or tables), only the text of the commands.\nYou can select a line in the History tab and click â€œTo Sourceâ€ to send it back to your permanent script.\n\n\nThe Broom Icon: Use the broom icon (top-right of the pane) or the shortcut Ctrl + L to clear the text if the window becomes cluttered. This does not delete your data; it just cleans your screen.\n\nNote: This only clears the â€œtextâ€ on the screen; it does not delete your data or variables.\n\nChecking Your R Version: The top of the Console displays your current R version (e.g., R 4.4.1). If a package fails to install, check here first to see if you need to update R.\n\nNote that updating RStudio (the software) does not automatically update R (the language engine).\n\n\n\n\n\n\n\n\nFinding Your Working Directory: Right next to your R version, you will see a file path starting with ~/. This is your Working Directoryâ€”the specific folder on your computer where R is currently â€œlookingâ€ for files.\n\nUnderstanding how R finds files is essential to avoiding the common \"File not found\" error:\n\n\n\n\n\n\n\n\nType\nDescription\nExample\n\n\nAbsolute Path\nThe full â€œGPS addressâ€ from your C: drive or User folder.\nC:/Users/Martina/Project/data/raw_counts.csv\n\n\nRelative Path\nA â€œshorthandâ€ address starting from your current folder.\nIn that case, your Working Directory must be set to: C:/Users/Martina/Project/\ndata/raw_counts.csv\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nBest Practice: We recommend putting your relative data and your R script in the same folder (or a sub-folder) and using Relative Paths. This makes your project â€œportableâ€â€”if you send the whole folder to a colleague, the code will still work on their computer!\n\n\n\n\n3.4 The Environment & History (Top-Right)\n\n\n\n\n\n\nEnvironment: This tab shows you every â€œobjectâ€ (datasets, variables, results) currently stored in Râ€™s memory. If a variable isnâ€™t listed here, R doesnâ€™t know it exists!\n\nThe â€œGolden Ruleâ€: If a variable or dataset isnâ€™t listed here, R does not know it exists! If you get an error saying Object not found, check this tab first to see if you successfully created or imported it.\n\nHistory: This tracks every single line of code you have run in the current session. If you forgot to save a line of code to your script, you can find it here.\nKey Features & Icons\n\n\n\n\n\n\nSave/Load Workspace (Disk Icons): These allow you to save your entire Environment as an .RData file. This is a huge time-saver for large projects; instead of re-running hours of code to recreate your variables, you can simply â€œLoadâ€ the .RData file and pick up exactly where you left off.\nImport Dataset Button: This is a â€œuser-friendlyâ€ wizard that helps you import Excel, CSV, or SPSS files without typing out the code yourself. Itâ€™s a great â€œshortcutâ€ for beginnersâ€”RStudio will even show you the code it generated so you can learn for next time.\nMemory Usage (Pie Chart): This shows how much of your computerâ€™s RAM is being used by R. If this number is extremely high, your computer may slow down or â€œlag.â€ This is common when working with massive genomic datasets or the UK Biobank.\nThe Broom Icon (Clear Environment): Clicking the broom will delete everything in your current Environment. Use this with caution! It is useful for a â€œfresh start,â€ but it cannot be undone.\n\n\n\n\n3.5 Files, Plots, & Help (Bottom-Right)\n\n\n\n\n\nThis is your â€œUtilityâ€ pane:\n\nFiles: A basic file explorer to navigate your computer.\nPlots: Where your visualizations (like GTT curves) will appear once you run your code.\nHelp: The most useful tab for beginners!\n\nThe Search Bar: You can type the name of any function (e.g., ggplot) or package (e.g., dplyr) directly into the search bar at the top of the Help pane.\nThe Console Shortcut: A faster way used by most R users is to type a question mark ? followed by the function name in the Console and hit Enter:\n\n?mean   # This opens the help page for the mean function\n?sd     # This opens the help page for standard deviation\n\nWhat to look for: R documentation can be dense, but you should always scroll to the very bottom to find the Examples section. You can copy and paste these examples directly into your console to see how the function works in action.",
    "crumbs": [
      "Get Acquainted with R and RStudio"
    ]
  },
  {
    "objectID": "WebsiteCodes/RStudio.html#hands-on-activity-use-help-in-rstudio",
    "href": "WebsiteCodes/RStudio.html#hands-on-activity-use-help-in-rstudio",
    "title": "Get Acquainted with R and RStudio",
    "section": "4. [HANDS-ON ACTIVITY] Use Help in RStudio",
    "text": "4. [HANDS-ON ACTIVITY] Use Help in RStudio\n\n\n\n\n\n\nNote\n\n\n\nR offers some good resources to help you learn about its functions. For example, if you put a question mark before a function name, on the lower right quadrant of RStudio some help will pop up.\n\n\n\n\nType ?sqrt in your script.\n\n\n\n?sqrt\n\n\n\nThen, help will pop up on the bottom right hand quadrant of RStudio.\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThese give documentation about how to use the function, what arguments it takes, and some example code. Example code might be a helpful page to start with.\n\n\n\n\nType ??read_excel.\n\n\n\n??read_excel\n\n\n\n\n\n\n\nNote\n\n\n\nYou can also precede a function name with two question marks ?? to search all of your installed packages for it.\nThis is useful if you know thereâ€™s some sort of R function but you donâ€™t remember what package itâ€™s in. So if you get some code with the function read-excel in it but you forgot to load the readxl package, you can search for it using this double question mark and itâ€™ll tell you which oneâ€™s to load.",
    "crumbs": [
      "Get Acquainted with R and RStudio"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions1.html#atomic-classes",
    "href": "WebsiteCodes/Solutions1.html#atomic-classes",
    "title": "Solutions: Data Types",
    "section": "1. Atomic Classes",
    "text": "1. Atomic Classes\n\nWrite a piece of code that stores a number in a variable and then check if it is greater than 5. Try to use comments!\nBonus: Is there a way to store the result after checking the number?\n\n\nx &lt;- 10\nx &gt; 5\n\n[1] TRUE\n\n#Bonus\ny &lt;- x &gt; 5\n\nprint(y)\n\n[1] TRUE",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼‘"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions1.html#vectors",
    "href": "WebsiteCodes/Solutions1.html#vectors",
    "title": "Solutions: Data Types",
    "section": "2. Vectors",
    "text": "2. Vectors\nMake a vector with the numbers 1 through 26. Multiply the vector by 2, and give the resulting vector names A through Z (hint: there is a built in vector called LETTERS).\n\nx &lt;- 1:26\nx &lt;- x * 2\nnames(x) &lt;- LETTERS\nprint(x)\n\n A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z \n 2  4  6  8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼‘"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions1.html#matrices",
    "href": "WebsiteCodes/Solutions1.html#matrices",
    "title": "Solutions: Data Types",
    "section": "3. Matrices",
    "text": "3. Matrices\nMake a matrix with the numbers 1:50, with 5 columns and 10 rows. Did the matrix function fill your matrix by column, or by row, as its default behavior? Once you have figured it out, try to change the default. (hint: read the documentation for matrix)\n\n# By default the matrix is filled by columns, we can change this behavior using byrow=TRUE\nm &lt;- matrix(1:50, ncol = 5, nrow = 10, byrow = T)\nprint(m)\n\n      [,1] [,2] [,3] [,4] [,5]\n [1,]    1    2    3    4    5\n [2,]    6    7    8    9   10\n [3,]   11   12   13   14   15\n [4,]   16   17   18   19   20\n [5,]   21   22   23   24   25\n [6,]   26   27   28   29   30\n [7,]   31   32   33   34   35\n [8,]   36   37   38   39   40\n [9,]   41   42   43   44   45\n[10,]   46   47   48   49   50\n\n\nBonus: Which of the following commands was used to generate the matrix below?\n\n\n\n\n[,1]\n[,2]\n\n\n[1,]\n4\n1\n\n\n[2,]\n9\n5\n\n\n[3,]\n10\n7\n\n\n\n\nmatrix(c(4, 1, 9, 5, 10, 7), nrow = 3)\nmatrix(c(4, 9, 10, 1, 5, 7), ncol = 2, byrow = TRUE)\nmatrix(c(4, 9, 10, 1, 5, 7), nrow = 2)\nmatrix(c(4, 1, 9, 5, 10, 7), ncol = 2, byrow = TRUE)\n\n\n# correct\nmatrix(c(4, 1, 9, 5, 10, 7), ncol = 2, byrow = TRUE)\n##      [,1] [,2]\n## [1,]    4    1\n## [2,]    9    5\n## [3,]   10    7\n\n# others\nmatrix(c(4, 1, 9, 5, 10, 7), nrow = 3)\n##      [,1] [,2]\n## [1,]    4    5\n## [2,]    1   10\n## [3,]    9    7\n\nmatrix(c(4, 9, 10, 1, 5, 7), ncol = 2, byrow = TRUE)\n##      [,1] [,2]\n## [1,]    4    9\n## [2,]   10    1\n## [3,]    5    7\n\nmatrix(c(4, 9, 10, 1, 5, 7), nrow = 2)\n##      [,1] [,2] [,3]\n## [1,]    4   10    5\n## [2,]    9    1    7\n\n\n\n\n\n\n\nNote\n\n\n\nThe byrow Argument\nThe matrix() function works like a worker filling a grid of boxes. The byrow argument tells that worker whether to walk across the rows or down the columns.\n\nbyrow = FALSE (Default): The worker fills the first column from top to bottom, then moves to the second column. This is â€œColumn-major order.â€\nbyrow = TRUE: The worker fills the first row from left to right, then moves to the second row. This is â€œRow-major order.â€",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼‘"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions1.html#lists",
    "href": "WebsiteCodes/Solutions1.html#lists",
    "title": "Solutions: Data Types",
    "section": "4. Lists",
    "text": "4. Lists\nCreate a list of length two containing a character vector for each of the data sections: (1) Data types and (2) Data structures. Populate each character vector with the names of the data types and data structures, respectively.\n\ndt &lt;- c('double', 'complex', 'integer', 'character', 'logical')\nds &lt;- c('data.frame', 'vector', 'factor', 'list', 'matrix')\ndata.sections &lt;- list(dt, ds)\nprint(data.sections)\n\n[[1]]\n[1] \"double\"    \"complex\"   \"integer\"   \"character\" \"logical\"  \n\n[[2]]\n[1] \"data.frame\" \"vector\"     \"factor\"     \"list\"       \"matrix\"",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼‘"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions1.html#data-frames",
    "href": "WebsiteCodes/Solutions1.html#data-frames",
    "title": "Solutions: Data Types",
    "section": "5. Data frames",
    "text": "5. Data frames\nThere are several subtly different ways to call variables, observations and elements from data frames. Try them all and discuss with your team what they return. (Hint, use the function typeof())\n\niris[1]\niris[[1]]\niris$Species\niris[\"Species\"]\niris[1,1]\niris[,1]\niris[1,]\n\n\n# The single brace [1] returns the first slice of the list, as another list. In this case it is the first column of the data frame.\nhead(iris[1])\n##   Sepal.Length\n## 1          5.1\n## 2          4.9\n## 3          4.7\n## 4          4.6\n## 5          5.0\n## 6          5.4\n\n# The double brace [[1]] returns the contents of the list item. In this case it is the contents of the first column, a vector of type factor.\nhead(iris[[1]])\n## [1] 5.1 4.9 4.7 4.6 5.0 5.4\n\n# This example uses the $ character to address items by name. Species is a vector of type factor.\nhead(iris$Species)\n## [1] setosa setosa setosa setosa setosa setosa\n## Levels: setosa versicolor virginica\n\n# A single brace [\"Species\"] instead of the index number with the column name will also return a list like in the first example\nhead(iris[\"Species\"])\n##   Species\n## 1  setosa\n## 2  setosa\n## 3  setosa\n## 4  setosa\n## 5  setosa\n## 6  setosa\n\n# First element of first row and first column. The returned element is an integer\niris[1,1]\n## [1] 5.1\n\n# First column. Returns a vector\niris[,1]\n##   [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1\n##  [19] 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5 4.9 5.0\n##  [37] 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0 6.4 6.9 5.5\n##  [55] 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8 6.2 5.6 5.9 6.1\n##  [73] 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4 6.0 6.7 6.3 5.6 5.5\n##  [91] 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8 7.1 6.3 6.5 7.6 4.9 7.3\n## [109] 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7 6.0 6.9 5.6 7.7 6.3 6.7 7.2\n## [127] 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8\n## [145] 6.7 6.7 6.3 6.5 6.2 5.9\n\n# First row. Returns a list with all the values in the first row.\niris[1,]\n##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n## 1          5.1         3.5          1.4         0.2  setosa",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼‘"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions1.html#coercion",
    "href": "WebsiteCodes/Solutions1.html#coercion",
    "title": "Solutions: Data Types",
    "section": "6. Coercion",
    "text": "6. Coercion\nTake the list you created in 4 and coerce it into a data frame. Then change the names of the columns to â€œdataTypesâ€ and â€œdataStructuresâ€\n\ndf &lt;- as.data.frame(data.sections)\ncolnames(df) &lt;- c(\"dataTypes\", \"dataStructures\")\nprint(df)\n\n  dataTypes dataStructures\n1    double     data.frame\n2   complex         vector\n3   integer         factor\n4 character           list\n5   logical         matrix\n\n\n\n\n\n\n\n\nNote\n\n\n\nCommon ways to change column names\n\ncolnames()\n\nIf you want to rename all the columns at once, this is the fastest method. You simply provide a vector of names that matches the number of columns.\n\n# Create a dummy dataframe\ndf &lt;- data.frame(V1 = 1:3, V2 = 4:6, V3 = 7:9)\n\n# Rename all columns\ncolnames(df) &lt;- c(\"ID\", \"Treatment\", \"Response\")\n\n\nIndexing\n\nIf you only want to change one specific column, you can use its index (position). This is great for small tables but risky for large ones if the column order changes.\n\n# Change only the 2nd column\ncolnames(df)[2] &lt;- \"Condition\"\n\n\ndplyr::rename()\n\nThis is the preferred method for most researchers because it is readable and safe. You donâ€™t need to know the index of the column, and you can pipe it into your analysis.\n\nSyntax: new_name = old_name\n\n\nlibrary(dplyr)\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\ndf &lt;- df %&gt;% \n  rename(Patient_ID = ID, \n         Dosage = Response)\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe â€œBacktickâ€ Trick: Column Names with Spaces\nUsually, R replaces spaces in column names with a dot (.) because spaces can break code. However, you can force R to accept them using Backticks (`).\n\nImportant Distinction: Notice the difference between Single Quotes (') and Backticks (`).\n\nQuotes (' '): Tell R that something is Text.\nBackticks (` `): Tell R that something is a Name that contains â€œillegalâ€ characters (like spaces or starting with a number).\n\n\n\n# This works because of the backticks!\ncolnames(df) &lt;- c(\"Data Types\", \"Data Structures\")\nprint(df)\n\n  Data Types Data Structures &lt;NA&gt;\n1          1               4    7\n2          2               5    8\n3          3               6    9\n\n# To call this column later, you MUST use backticks:\ndf$`Data Types`\n\n[1] 1 2 3\n\n\nWhy we avoid spaces in Bioinformatics\nWhile R can handle spaces, it is generally discouraged in professional pipelines for several reasons:\n\nTab Completion: If you type df$d... and hit Tab, RStudio can instantly find data_types. If there is a space, you have to manually type the backticks every single time.\nCompatibility: If you export your data to a colleague using Python or a command-line tool like awk, spaces in column names can cause their scripts to crash.\nThe â€œSnake Caseâ€ Standard: Most researchers prefer snake_case (e.g., gene_id) or camelCase (e.g., geneId).",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼‘"
    ]
  },
  {
    "objectID": "WebsiteCodes/Solutions3.html",
    "href": "WebsiteCodes/Solutions3.html",
    "title": "Solutions: Advance Data Manipulation",
    "section": "",
    "text": "suppressPackageStartupMessages(library(gapminder))\nsuppressPackageStartupMessages(library(dplyr))\n\nWrite one command ( can span multiple lines) using pipes that will output a data frame that has only the columns lifeExp, country and year for the records before the year 2000 from African countries, but not for other Continents.\n\ntidy_africa &lt;- gapminder %&gt;%\n                dplyr::filter(continent == \"Africa\") %&gt;%\n                dplyr::select(year, country, lifeExp)\nhead(tidy_africa)\n\n# A tibble: 6 Ã— 3\n   year country lifeExp\n  &lt;int&gt; &lt;fct&gt;     &lt;dbl&gt;\n1  1952 Algeria    43.1\n2  1957 Algeria    45.7\n3  1962 Algeria    48.3\n4  1967 Algeria    51.4\n5  1972 Algeria    54.5\n6  1977 Algeria    58.0\n\n\nCalculate the average life expectancy per country. Which country has the longest average life expectancy and which one the shortest average life expectancy?\n\ngapminder %&gt;%\n   dplyr::group_by(country) %&gt;%\n   dplyr::summarize(mean_lifeExp = mean(lifeExp)) %&gt;%\n   dplyr::filter(mean_lifeExp == min(mean_lifeExp) | mean_lifeExp == max(mean_lifeExp))\n\n# A tibble: 2 Ã— 2\n  country      mean_lifeExp\n  &lt;fct&gt;               &lt;dbl&gt;\n1 Iceland              76.5\n2 Sierra Leone         36.8\n\n\nIn the previous hands-on you discovered that all the entries from 2007 are actually from 2008. Write a command to edit the data accordingly using pipes. In the same command filter only the entries from 2008 to verify the change.\n\ngapminder %&gt;%\n  dplyr::mutate(year = ifelse(year==2007,2008,year)) %&gt;%\n  dplyr::filter(year==2008) %&gt;%\n  head()\n\n# A tibble: 6 Ã— 6\n  country     continent  year lifeExp      pop gdpPercap\n  &lt;fct&gt;       &lt;fct&gt;     &lt;dbl&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;\n1 Afghanistan Asia       2008    43.8 31889923      975.\n2 Albania     Europe     2008    76.4  3600523     5937.\n3 Algeria     Africa     2008    72.3 33333216     6223.\n4 Angola      Africa     2008    42.7 12420476     4797.\n5 Argentina   Americas   2008    75.3 40301927    12779.\n6 Australia   Oceania    2008    81.2 20434176    34435.",
    "crumbs": [
      "ğŸ‘ï¼³ï¼¯ï¼¬ï¼µï¼´ï¼©ï¼¯ï¼®ï¼³ï¼ƒï¼“"
    ]
  },
  {
    "objectID": "WebsiteCodes/WhyR.html",
    "href": "WebsiteCodes/WhyR.html",
    "title": "Foundations of R: Why R for Data Science?",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nCritique the limitations of spreadsheet software (like Excel) in the context of professional scientific research and reproducibility.\nDefine the fundamental nature of R as an open-source, community-driven statistical language.\nIdentify key R applications in bioinformatics, data visualization, and automated reporting.\nEvaluate the strengths of R vs.Â Python to make informed decisions for your specific research or career path.\nNavigate a curated list of self-taught resources to continue your R journey beyond this workshop.",
    "crumbs": [
      "Why R for Data Science?"
    ]
  },
  {
    "objectID": "WebsiteCodes/WhyR.html#learning-objectives",
    "href": "WebsiteCodes/WhyR.html#learning-objectives",
    "title": "Foundations of R: Why R for Data Science?",
    "section": "",
    "text": "By the end of this module, you will be able to:\n\nCritique the limitations of spreadsheet software (like Excel) in the context of professional scientific research and reproducibility.\nDefine the fundamental nature of R as an open-source, community-driven statistical language.\nIdentify key R applications in bioinformatics, data visualization, and automated reporting.\nEvaluate the strengths of R vs.Â Python to make informed decisions for your specific research or career path.\nNavigate a curated list of self-taught resources to continue your R journey beyond this workshop.",
    "crumbs": [
      "Why R for Data Science?"
    ]
  },
  {
    "objectID": "WebsiteCodes/WhyR.html#why-not-excel-why-not-graphpad-prism",
    "href": "WebsiteCodes/WhyR.html#why-not-excel-why-not-graphpad-prism",
    "title": "Foundations of R: Why R for Data Science?",
    "section": "1. Why Not Excel? / Why Not GraphPad Prism?",
    "text": "1. Why Not Excel? / Why Not GraphPad Prism?\nExcel is a fantastic tool for initial data entry and simple calculations. GraphPad Prism is also widely used for statistical analysis and data visualization.\nHowever, for professional scientific research, it has some limitations that can compromise your results.\n\nThe Limitations of Spreadsheets and Prism\n\nInflexible with Large Data: Large datasets (like genomic data) often cause Excel to lag or crash. Searching a 100MB spreadsheet can take minutes in Excel.\n\nIn R, the same search takes milliseconds. R is designed to handle millions of rows efficiently and uses optimized data compression to keep your workflow fast.\n\nAutomatic â€œAuto-Correctâ€ Errors: Excel is famous for â€œhelpfullyâ€ converting gene names like MARCH1 into dates (e.g., 01-March-2025). This has historically corrupted thousands of published papers.\n\nIn R, your data is treated as pure text by default. R wonâ€™t change your data unless you explicitly tell it to.\nNote: The only common â€œauto-changeâ€ in R is the word NA, which R reserves for â€œNot Availableâ€ (missing data)â€”we will discuss this later.\n\nPoor Reproducibility: In Excel, if you accidentally delete a cell or change a value, there is no â€œaudit trail.â€ You might never notice the mistake.\n\nIn R, every change is documented in your code. You can add comments to explain why you made a change, allowing you (and your collaborators) to follow your logic months later.\n\nVersion Incompatibility: We have all experienced an Excel file that looks perfect on a Mac but appears broken or â€œskewedâ€ when opened on Windows or in different software like Numbers or WPS.\n\nR is a pure programming language, meaning your code will run exactly the same way regardless of the operating system.\n\nThe â€œCopy-Pasteâ€ Risk: Many students store data in Excel but copy-paste it into software like GraphPad Prism or SPSS for analysis. This manual step is a major source of human error. Itâ€™s easy to lose track of which version of the data you copied.\n\nIn R, you import your data directly via code. This creates a clear, permanent link between your raw data and your final results.\n\nCost: One major limitation of GraphPad Prism is its price: approximately $500+ per year for two seats, rising to $1,000+ per year for larger labs.\n\nR is completely free and open-source.\n\n\n\n\n\n\n\n\nNoteMy Personal Recommendation\n\n\n\nExcel remains the most user-friendly interface for manual data entry and â€œbeautifyingâ€ simple tables for quick viewing.\nI personally recommend a hybrid workflow:\n\nUse Excel (specifically saving as .csv files rather than .xlsx, just my personal preference) for initial data storage.\nUse R for all subsequent data cleaning, statistical analysis, and publication-quality visualization.",
    "crumbs": [
      "Why R for Data Science?"
    ]
  },
  {
    "objectID": "WebsiteCodes/WhyR.html#what-is-r",
    "href": "WebsiteCodes/WhyR.html#what-is-r",
    "title": "Foundations of R: Why R for Data Science?",
    "section": "2. What is R?",
    "text": "2. What is R?\nR is more than just a tool; it is a Statistical Programming Language designed by scientists, for scientists. It is an integrated suite for data manipulation, calculation, and graphical display.\n\nThe â€œFreeâ€ in Free Software\nIn the world of coding, we often say R is â€œFree as in Speech, not just free as in beer.â€ This means it isnâ€™t just about the cost ($0); it is about the freedom to use and share it.\nThis philosophy gives you four fundamental freedoms:\n\nUnlimited Use: You can run the program for any purpose (academic, commercial, or personal) without expensive licenses.\nFull Transparency: You can study how every single calculation is performed. There is no â€œblack boxâ€ logic hidden from the scientist.\nCollaborative Sharing: You can freely share your scripts and tools with colleagues anywhere in the world.\nContinuous Improvement: Anyone can fix a bug or add a new feature, which is why R has such a massive library of scientific packages.\n\n\n\nKey R Facts\n\nInterpreted: You type code, and R runs it immediatelyâ€”no complex â€œcompilingâ€ needed.\n\nIf you make a mistake, you can correct it in your next sentence. You type a line of code in the console, hit Enter, and R gives you the answer immediately.\nC++/JAVA (Compiled) is like a Book Publisher. Imagine you are writing a novel in English that needs to be translated into French. You have to write the entire book first. You send the whole manuscript to a publisher (the â€œCompilerâ€). They translate the whole thing at once into a new, separate book. You can only â€œreadâ€ the results once the entire translation process is finished. If there is a typo on page 1, you might not find out until the whole book is printed. This is Compiling: It makes the final program run very fast, but it makes the writing process much slower for the person doing it.\n\nObject-Oriented: Everything in R (data, plots, models) is an â€œobjectâ€ that you can save and reuse.\n\nImagine these objects as labeled boxes on your desk. Each â€œboxâ€ (object) has its own name, a specific type of content (its class), and a specific size. You can save these boxes individually or pack them all up together to use later.\n\nCase Sensitive: my_data and My_Data are seen as two different things.\n\nTips: Some R users prefer using all lowercase and underscores (e.g., blood_pressure) to avoid simple typing errors.\n\n1-Based Indexing: Unlike Python (which starts at 0), R starts counting at 1. This is much more intuitive for most researchers!\n\nJust like in Excel, your rows start at 1, 2, 3â€¦ and your columns start at A, B, C (1, 2, 3â€¦).\nIn contrast, languages like Python start counting at 0, which can be confusing if you arenâ€™t a software engineer!\n\nNo Spaces in Variable Names: R cannot â€œreadâ€ a space inside a name because it thinks the space means the command has ended.\n\nThe Rule: If you try to name a dataset Patient Data, R will look for an object called Patient and then get confused by the word Data.\nThe Solution: Most researchers use underscores (patient_data) or CamelCase (PatientData) to connect words.\n\nAllows User-Defined Functions: Beyond the built-in tools, R allows you to build your own â€œcustom machinesâ€ to perform repetitive tasks.\n\nHow it works: If you find yourself doing the same three steps to clean your data every single morning, you can write a Function that bundles those steps into one single command. Itâ€™s like creating your own custom button in a software program that does exactly what you need.\n\nWorks with Environments: Think of an â€œEnvironmentâ€ as your Active Workspace or your digital desk.\n\nThe Concept: When you import a file or create a variable, it lives in your â€œGlobal Environment.â€ In RStudio, you can actually see this list in the top-right pane.\nAnalogy: If your â€œObjectsâ€ are the labeled boxes, the â€œEnvironmentâ€ is the room where those boxes are stored. R can handle multiple â€œroomsâ€ at once, which helps keep your variables from getting mixed up when youâ€™re running complex analyses or using different packages.",
    "crumbs": [
      "Why R for Data Science?"
    ]
  },
  {
    "objectID": "WebsiteCodes/WhyR.html#what-can-r-do",
    "href": "WebsiteCodes/WhyR.html#what-can-r-do",
    "title": "Foundations of R: Why R for Data Science?",
    "section": "3. What Can R Do?",
    "text": "3. What Can R Do?\nR is a â€œSwiss Army Knifeâ€ for researchers.\nIt excels at:\n\nData Cleaning: Tidying messy â€œreal-worldâ€ data into a usable format.\n\nBig Data Handling: Have you ever tried to open a BioBank dataset with thousands of patients, hundreds of clinical variables, and tens of thousands of gene expression data points?\nSpeed: While these 100MB+ (or even multi-GB) files can crash Excel, R is designed to process them efficiently. What takes minutes of â€œloadingâ€ in a spreadsheet takes only seconds in R.\n\nStatistics & Machine Learning: From simple T-tests to complex predictive modeling, R provides a rigorous environment for:\n\nClassical statistical testing.\n\nPerform the standard t-tests, ANOVA, and Chi-square tests you need to show your PI those all-important p-values and significant differences.\n\nLinear and non-linear modeling.\nMachine learning algorithms for predicting disease outcomes or drug responses.\nBayesian & Advanced Statistics: R is the â€œhomeâ€ of modern statistics. If you want to use Bayesian models or other â€œfancyâ€ statistical methods to handle uncertainty in your research, R has the most robust tools available.\n\nBioinformatics: Thousands of specialized tools (via Bioconductor) for DNA/RNA/Protein analysis.\n\nGenomics: DNA and RNA sequencing analysis (e.g., DESeq2).\nProteomics: Analyzing protein expression and interaction.\nSingle-Cell Analysis: Processing complex cellular data (e.g., Seurat).\n\nVisualization: Creating publication-quality plots that are far more beautiful than Excelâ€™s defaults.\n\nOne of Râ€™s greatest strengths is ggplot2. You can create figures that are not only â€œGraphPad Prism levelâ€ but often far superior in terms of customization and complexity.\nRepeatability: Once you design a beautiful plot, you can apply that same style to 100 different datasets with one click.\nProfessionalism: Most high-impact journals (Nature, Science, Cell) feature plots created directly in R.\nHere are a few of my visualization examples made entirely in R.\n\nCommunication: R isnâ€™t just for math; itâ€™s for sharing your work. You can build:\n\nInteractive Web Apps: Using R Shiny.\n\nExample: Bayesian Diagnostic Test Accuracy Meta-Analysis\nExample: shinyDeepDR: Deep Learning Prediction of Cancer Drug Response.\n\nReproducible Documents: Writing your entire Masterâ€™s thesis or Research Day posters or eBooks using Quarto (like this website!).",
    "crumbs": [
      "Why R for Data Science?"
    ]
  },
  {
    "objectID": "WebsiteCodes/WhyR.html#r-vs.-python-how-to-choose",
    "href": "WebsiteCodes/WhyR.html#r-vs.-python-how-to-choose",
    "title": "Foundations of R: Why R for Data Science?",
    "section": "4. R vs.Â Python: How to Choose?",
    "text": "4. R vs.Â Python: How to Choose?\nThis is the most common question for beginners. Both are excellent, but they serve different strengths.\n\n\n\n\n\n\n\n\nFeature\nR\nPython\n\n\n\n\nOrigins\nCreated by Statisticians\nCreated by Software Engineers\n\n\nBest For\nData Analysis & Visualization\nMachine Learning & Production\n\n\nBioinformatics\nDeep roots in genomics/math\nStrong in imaging and deep learning\n\n\nCareer Path\nAcademia, Medicine, Economics\nTech Industry, AI, Web Dev\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nOur Advice:\nIf your primary goal is to analyze your own research data and publish papers, start with R.\nIf you eventually want to move into pure software engineering or heavy AI, you can study Python later.\nThe logic you learn in R will make Python much easier to learn!",
    "crumbs": [
      "Why R for Data Science?"
    ]
  },
  {
    "objectID": "WebsiteCodes/WhyR.html#how-to-use-ai-as-a-learning-accelerator",
    "href": "WebsiteCodes/WhyR.html#how-to-use-ai-as-a-learning-accelerator",
    "title": "Foundations of R: Why R for Data Science?",
    "section": "5. How to use AI as a Learning Accelerator?",
    "text": "5. How to use AI as a Learning Accelerator?\nWith the rise of powerful AI tools, many students ask: â€œIf AI can write executable code for me, why should I spend time learning R myself?â€\nIt is true that AI can be a brilliant assistantâ€”even experienced bioinformaticians use it to explore new functions or speed up repetitive tasks. However, to be a scientist, you must move beyond â€œcopy-pastingâ€ to â€œcomprehending.â€\n\nWhy Foundational Knowledge Still Matters\n\n1. Fluency in the Environment\nYou must understand the RStudio interface and foundational functions to work fluently. Relying 100% on AI is like using a GPS but not knowing how to drive the car; if the GPS loses signal, you are stranded.\n\n\n2. The Critical Skill of Debugging\nAI often provides code that is â€œalmostâ€ right but fails due to your specific data structure. You must learn to read error messages and understand the â€œwhyâ€ behind a bug to fix it. Without this, you will spend more time arguing with the AI than actually analyzing your data.\n\n\n3. The â€œBlack Boxâ€ Risk (A Cautionary Tale)\nBlindly trusting AI is dangerous. There are documented cases of users running AI-generated scripts that accidentally deleted entire directories because they didnâ€™t read the line containing unlink() or rm(). As a researcher, you are responsible for the integrity of your data. If you donâ€™t read the code, you are not in control of your research.\nI recently heard a real case in which someone copy-pasted AI-generated code without fully reviewing it. A single incorrect command permanently deleted all of their files.\n\n\n4. Expanding Your â€œMental Toolboxâ€\nBy making an effort to understand each line of code, you build a mental library of what is possible. The next time you face a complex genomic problem, you wonâ€™t just ask AI for a solutionâ€”you will know which R tools (like dplyr or ggplot2) are the right ones for the job.\n\n\n\nThe â€œPilot and Co-Pilotâ€ Rule\nThink of yourself as the Pilot and the AI as your Co-pilot.\n\nThe Pilot sets the destination, understands the flight plan, and double-checks the instruments.\nThe Co-pilot handles the manual, repetitive tasks to make the flight smoother.\n\n\n\n\n\n\n\nImportant\n\n\n\nNever give 100% of your trust to an external resource.\nWhether it is code from an AI or a snippet from a forum, you must master the logic behind it. Master your code, and you master your research.",
    "crumbs": [
      "Why R for Data Science?"
    ]
  },
  {
    "objectID": "WebsiteCodes/WhyR.html#recommended-learning-materials",
    "href": "WebsiteCodes/WhyR.html#recommended-learning-materials",
    "title": "Foundations of R: Why R for Data Science?",
    "section": "6. Recommended Learning Materials",
    "text": "6. Recommended Learning Materials\nIf you want to dive deeper, here is a few free online books and materials:\n\nR for Data Science (2e)\nR Graphics Cookbook, 2nd edition\nR in Action, Second Edition\nHands-On Programming with R\nThe Epidemiologist R Handbook\nR for Non-Programmers: A Guide for Social Scientists\nCodecademy: Learn R Free Course: Good for those who prefer an interactive, â€œin-browserâ€ coding experience to practice syntax.\nMcGill CDSI Workshops: Our colleagues at the Computational and Data Systems Institute offer excellent deep-dives into specific data topics.\nMcGill QLS-MiCM Workshops: Keep an eye on future MiCM workshops for specialized bioinformatics and high-performance computing training.",
    "crumbs": [
      "Why R for Data Science?"
    ]
  },
  {
    "objectID": "WebsiteCodes/WhyR.html#visualization-gallery",
    "href": "WebsiteCodes/WhyR.html#visualization-gallery",
    "title": "Foundations of R: Why R for Data Science?",
    "section": "Appendix: R Visualization Gallery",
    "text": "Appendix: R Visualization Gallery\nBelow are a few examples of my visualizations created entirely in R using ggplot2 and specialized bioinformatics packages.\n\n\n\n\n\n\nFigureÂ 1: Boxplot with Individual Data Points\n\n\n\n\n\n\n\n\n\nFigureÂ 2: Boxplot with Individual Data Points and Statistics\n\n\n\n\n\n\n\n\n\nFigureÂ 3: A Time-Course Line Plot with an Area Under the Curve (AUC) Boxplot.\n\n\n\n\n\n\n\n\n\nFigureÂ 4: Correlation Plot with Statistical Results\n\n\n\n\n\n\n\n\n\nFigureÂ 5: Heatmap\n\n\n\n\n\n\n\n\n\nFigureÂ 6: Forest Plot",
    "crumbs": [
      "Why R for Data Science?"
    ]
  }
]